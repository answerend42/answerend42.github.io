<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UVA11572 唯一的雪花 Unique Snowflakes</title>
    <url>/2023/07/06/uva11572/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/UVA11572" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>企业家 Emily 有一个很酷的主意：把雪花包起来卖。她发明了一台机器，这台机器可以捕捉飘落的雪花，并把它们一片一片打包进一个包裹里。一旦这个包裹满了，它就会被封上送去发售。</p>
<p>Emily 的公司的口号是“把独特打包起来”，为了实现这一诺言，一个包裹里不能有两片一样的雪花。不幸的是，这并不容易做到，因为实际上通过机器的雪花中有很多是相同的。Emily 想知道这样一个不包含两片一样的雪花的包裹最大能有多大，她可以在任何时候启动机器，但是一旦机器启动了，直到包裹被封上为止，所有通过机器的雪花都必须被打包进这个包裹里，当然，包裹可以在任何时候被封上。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是测试数据组数 $T$，对于每一组数据，第一行是通过机器的雪花总数 $n$（$n \le {10}^6$），下面 $n$ 行每行一个在 $[0, {10}^9]$ 内的整数，标记了这片雪花，当两片雪花标记相同时，这两片雪花是一样的。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一组数据，输出最大包裹的大小。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>模拟一个滑动窗口的左端、右端，通过去重取均不重复区间的长度最大值</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, a[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        cnt.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, rep = <span class="number">0</span>;</span><br><span class="line">        cnt[a[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; r &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">                r++;</span><br><span class="line">                cnt[a[r]]++;</span><br><span class="line">                <span class="keyword">if</span> (cnt[a[r]] &gt; <span class="number">1</span>)</span><br><span class="line">                    rep++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[a[l]]--;</span><br><span class="line">                <span class="keyword">if</span> (cnt[a[l]] == <span class="number">1</span>)</span><br><span class="line">                    rep--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>多测记得换行</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图汇总</title>
    <url>/2020/11/28/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<object data="./二分图汇总.pdf" type="application/pdf" width="100%" height="900px"></object>

<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>「JOI 2014 Final」IOI 馒头</title>
    <url>/2020/11/25/loj2757/</url>
    <content><![CDATA[<p><a href="https://loj.ac/p/2757" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul>
<li><p>有 $M$ 种互不相同的馒头各一个，第 $i$ 个馒头卖 $P_i$ 元。</p>
<p>有 $N$ 个包装盒，第 $j$ 个包装盒最多能装 $C_j$ 个馒头，买第 $j$ 个包装盒的花费为 $E_j$ 元。要求只能将一些馒头放进包装盒中打包出售，不能零售，当然也可以不出售某些馒头。售出一盒馒头得到的利润为盒内所有馒头的价格减去包装盒的价格。</p>
<p>现在买下（这 $N$ 个包装盒）其中的一些包装盒（也可以不买，还可以全买），将馒头打包出售，求最大可能利润。</p>
</li>
</ul>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数 $M,N$，意义如题目描述；<br>接下来 $M$ 行，每行一个正整数  $P_i$，表示第 $i$ 个馒头的价格；<br>接下来 $N$ 行，每行两个正整数 $C_j,E_j$，表示第 $j$ 个包装盒最多能装 $C_j$个馒头，花费 $E_j$ 元。</p>
<p>对于全部数据，$1 \le M \le 10^4, 1 \le N\le 500, 1 \le P_i,C_j,E_j \le 10^4$。</p>
<p>详细子任务及数据满足条件如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Subtask</th>
<th style="text-align:center">追加限制</th>
<th style="text-align:center">分值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$N \le 10$</td>
<td style="text-align:center">$25$</td>
</tr>
<tr>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$C_j \le 10$</td>
<td style="text-align:center">$35$</td>
</tr>
<tr>
<td style="text-align:center">$3$</td>
<td style="text-align:center">无追加限制</td>
<td style="text-align:center">$45$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示最大可能利润。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心的想，既然要求最大利润，应当保证所选的包装盒内装的馒头全部为尽可能售出价格更高的馒头。</p>
<p>问题转换成恰有 $\sum C_j$ 个馒头可装时花费 $\sum E_j$ 的最小值（因为卖出的最大值已经确定了）</p>
<p>这是一个典型的背包模型</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c, e;</span><br><span class="line">&#125; e[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]), d[i] = d[i - <span class="number">1</span>] + p[i], dp[i] = inf;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + m, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) d[i] = d[i - <span class="number">1</span>] + p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;e[i].c, &amp;e[i].e);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[max(<span class="number">0</span>, j - e[i].c)] + e[i].e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) ans = max(ans, d[i] - dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>注意转移的时候方程应该是 $dp(j) = \min {dp(j), dp(j - C)}$，但有可能 $j &lt; C$ 从而访问负数下标，因此是 $dp(j) = \min \{ dp(j), dp(\max \{ 0,j - C \}) \}$ 从实际意义来谈，也不可能选取负数个馒头</li>
<li>求最小值初始化为最大值</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1156 垃圾陷阱</title>
    <url>/2020/11/23/lg1156/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1156" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>卡门――农夫约翰极其珍视的一条<code>Holsteins</code>奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为$D(2 \le D \le 100)$英尺。</p>
<p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p>
<p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p>
<p>假设卡门预先知道了每个垃圾扔下的时间 $t(0&lt; t \le 1000)$，以及每个垃圾堆放的高度 $h(1 \le h \le 25$)和吃进该垃圾能维持生命的时间 $f(1 \le f \le 30)$，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内没有进食，卡门就将饿死。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为 $2$ 个整数，$D$ 和 $G (1 \le  G \le 100)$，$G$ 为被投入井的垃圾的数量。</p>
<p>第二到第 $G+1$ 行每行包括$3$个整数：$T (0 &lt; T &lt;= 1000)$，表示垃圾被投进井中的时间；$F (1 \le F  \le 30)$，表示该垃圾能维持卡门生命的时间；和 $H (1 \le  H \le  25)$，该垃圾能垫高的高度。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果卡门可以爬出陷阱，输出一个整表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道 DP，很像一道背包问题，但是其“不选”的含义变成了吃掉以维持生命。</p>
<p>设计状态的时候考虑 <code>dp[i][j]</code> 表示第 $i$ 个物品，到高度 $j$ 时生命的最大值</p>
<p>方程</p>
<script type="math/tex; mode=display">
\begin{align}
dp(0,0)&= 10\\
dp(i,j)&= \max \{dp(i,j),dp(i-1,j)+f\}\ \ (dp(i-1,j)\ge t) \\
dp(i,j)&= \max \{dp(i,j),dp(i-1,j-h)\}\ \ (dp(i-1,j-h) \ge t)
\end{align}</script><p>观察到和 $i$ 无关，可以滚动数组压掉一维</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d, g;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, f, h;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;nd) <span class="keyword">const</span> &#123; <span class="keyword">return</span> nd.t &gt; t; &#125;</span><br><span class="line">&#125; a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];  <span class="comment">// 第 i 个物品，到高度 j 时的最大生命值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;d, &amp;g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a[i].t, &amp;a[i].f, &amp;a[i].h);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + g);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= d; j++) &#123;</span><br><span class="line">            <span class="comment">// 吃掉 dp[i][j] = dp[i - 1][j] + a[i].f;</span></span><br><span class="line">            <span class="comment">// 用掉 dp[i][j] = dp[i-1][j - a[i].h];</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= a[i].t)</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j] + a[i].f, dp[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j - a[i].h] &gt;= a[i].t)</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j - a[i].h], dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxh = <span class="number">0</span>, maxt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= g; i++) &#123;</span><br><span class="line">        maxt = max(maxt, dp[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= d; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] - a[i].t &gt;= <span class="number">0</span>) maxh = max(maxh, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxh == d) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxh == d)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i].t);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>本题中当前生命为 $0$ 是合法状态，仍可以操作</li>
<li>本题垃圾以<strong>非时间顺序</strong>给出，要首先排序</li>
<li>如果不能到达井外，计算高度时要考虑时间（能不能撑到下一个垃圾）</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P7100 [w3R1] 团</title>
    <url>/2020/11/22/lg7100/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7100" target="_blank" rel="noopener">原题链接</a></p>
<p><a href="https://www.luogu.com.cn/blog/220037/w33z-round-1-ti-xie" target="_blank" rel="noopener">官方题解</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我有一张 $n$ 个节点的无向边带权图。它的边很多，用这个方法表示：</p>
<ul>
<li>有 $k$ 个集合；第 $i$ 个集合可以表示为 $S<em>i={(T_1,W_1),(T_2,W_2),\dots,(T</em>{|S<em>i|},W</em>{|S_i|})}$。</li>
<li>对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$。</li>
</ul>
<p>请对于所有节点 $i$ 找到 $1$ 到 $i$ 的最短路，即从 $1$ 到 $i$ 的边权和最小的简单路径。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数 $n,k$。<br>接下来描述 $k$ 个集合。<br>第 $i$ 集合的描述的第一行一个正整数 $|S_i|$，表示 $|S_i|$ 的大小。<br>接下来 $S_i$ 行，每行两个正整数 $t,w$，表示 $(t,w)\in S_i$。</p>
<p>对于前 $10\%$ 的数据，$|S_i|=2$；<br>对于前 $20\%$ 的数据，$|S_i|\le10$；<br>对于前 $50\%$ 的数据，$|N|\le1000,\sum|S_i|\le2000$；<br>对于 $100\%$ 的数据，$1\le|N|\le2\cdot10^5,\sum|S_i|\le4\cdot10^5,0\le W_i\le10^9$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行 $n$ 个正整数；第 $i$ 个正整数表示 $1$ 到 $i$ 的最短路长度。如果不存在一条路径，输出 $\textsf{0x3f3f3f3f3f3f3f3f}=4557430888798830399$。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol>
<li><p>暴力建图，跑 Dijkstra，可以通过前 $50\%$ 的数据</p>
</li>
<li><p>对于 $100\%$ 的数据，仍然使用暴力建图并采用优先队列优化的 Dijkstra 就是 $\mathcal{O}(\sum |S^2_i| \log \sum |S^2_i|)$ 的复杂度，不能接受，考虑如何优化建图。</p>
<p>每个集合中所有点总要两两连边，这样边数是 $|S^2| - |S|$($\dfrac{|S| \times (|S|-1)}{2} \times 2$)的，将其转换一下，对于每一个集合设立一个中间点，所有的点 $T_i$ 向其连一条边权为 $W_i$ 的边，和原图实际上是等价的，边数变成了 $2|S|$。</p>
<p>以样例为例：</p>
<p><img src="https://i.loli.net/2020/11/22/UpRceOrI4JZdz8H.png" alt="优化前的原图"></p>
<p><img src="https://i.loli.net/2020/11/22/cztZGfCdMI87rLn.png" alt="优化建图后(6,7为中间点)"></p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>, M = N &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> tot, head[N], to[M], nxt[M];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll cst[M], dis[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n, k, siz, x;</span><br><span class="line">ll y;</span><br><span class="line"><span class="keyword">int</span> Mid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll x, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> rhs.dis &lt; dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123; to[++tot] = y, cst[tot] = z, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Mid; i++) dis[i] = INF;</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    q.push(Node&#123; u, <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.top().x;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[t]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[t]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[t] + cst[i]) &#123;</span><br><span class="line">                dis[v] = dis[t] + cst[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.push(Node&#123; v, dis[v] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    Mid = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; siz;</span><br><span class="line">        Mid++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= siz; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; b[j];</span><br><span class="line">            add(x, Mid, b[j]);</span><br><span class="line">            add(Mid, x, b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dij(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>本题<strong>需要</strong> long long</li>
<li>图<strong>不一定</strong>联通</li>
<li>每一个集合的中间点都是<strong>不同</strong>的（代码中用 $n+1 \sim n+k$ 表示）</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P1226 【模板】快速幂||取余运算</title>
    <url>/2020/11/21/lg1226/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1226" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你三个整数 $b,p,k$，求 $b^p \bmod k$。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行三个整数，分别代表 $b,p,k$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串 <code>b^p mod k=s</code>，其中 $b, p, k$($0 \le b,p &lt; 2^{31},1 \le k \le 2^{31}$) 分别为题目给定的值，$s$ 为运算结果。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如此巨大的数据，当然不能直接暴力，考虑幂次方的性质，要求 $a^4$ 相当于求出 ${a^2}^2$，以此类推，对 $b$ 作二进制分解，只用求出二进制位上为 $1$ 的位之积就是答案</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll b, p, k;</span><br><span class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(ll b, ll p, ll k)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> % k;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * b % k;</span><br><span class="line">        b = b * b % k;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;b, &amp;p, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld^%lld mod %lld=%lld"</span>, b, p, k, fast_pow(b, p, k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>数据经过更新，要考虑 $k = 1$ 的情况所以 <code>res = 1 % k</code></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>P2831 愤怒的小鸟</title>
    <url>/2020/11/15/lg2831/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2831" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><code>Kiana</code> 最近沉迷于一款神奇的游戏无法自拔。</p>
<p>简单来说，这款游戏是在一个平面上进行的。</p>
<p>有一架弹弓位于 $(0,0)$ 处，每次 <code>Kiana</code> 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 <code>Kiana</code> 指定的参数，且必须满足 $a &lt; 0$，$a,b$ 都是实数。</p>
<p>当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。</p>
<p>在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。</p>
<p>如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；</p>
<p>如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。</p>
<p>例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，<code>Kiana</code> 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。</p>
<p>而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。</p>
<p>这款神奇游戏的每个关卡对 <code>Kiana</code>来说都很难，所以<code>Kiana</code>还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。</p>
<p>假设这款游戏一共有 $T$ 个关卡，现在 <code>Kiana</code>想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个正整数 $T$，表示游戏的关卡总数。</p>
<p>下面依次输入这 $T$ 个关卡的信息。每个关卡第一行包含两个非负整数 $n,m$，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的 $n$ 行中，第 $i$ 行包含两个正实数 $x_i,y_i$，表示第 $i$ 只小猪坐标为 $(x_i,y_i)$。数据保证同一个关卡中不存在两只坐标完全相同的小猪。</p>
<p>如果 $m=0$，表示 <code>Kiana</code> 输入了一个没有任何作用的指令。</p>
<p>如果 $m=1$，则这个关卡将会满足：至多用 $\lceil n/3 + 1 \rceil$ 只小鸟即可消灭所有小猪。</p>
<p>如果 $m=2$，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 $\lfloor n/3 \rfloor$ 只小猪。</p>
<p>保证 $1\leq n \leq 18$，$0\leq m \leq 2$，$0 &lt; x_i,y_i &lt; 10$，输入中的实数均保留到小数点后两位。</p>
<p>上文中，符号 $\lceil c \rceil$ 和 $\lfloor c \rfloor$ 分别表示对 $c$ 向上取整和向下取整，例如：$\lceil 2.1 \rceil = \lceil 2.9 \rceil = \lceil 3.0 \rceil = \lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每个关卡依次输出一行答案。</p>
<p>输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道十足的搜索好题，可以用于练习 bfs。</p>
<p>首先做简单的数学推导，推出经过 $(x_1,y_1)$，$(x_2,y_2)$ 的抛物线</p>
<script type="math/tex; mode=display">
f(x_1) = y_1 = ax_1^2 + bx_1 \\ 
f(x_2) = y_2 = ax_2^2 + bx_2 \\
a = \dfrac{y_1 - bx_1}{x_1^2} = \dfrac{y_2 - bx_2}{x_2^2} \\
b = \dfrac{x_2^2y_1 - x_1^2y_1}{x_1x_2(x_2 - x_1)}</script><p>用二进制表示第 $i$ 个猪是否被打到（状态压缩）</p>
<p>每次通过极角序排序每个点，作为枚举顺序，最后 $\mathcal{O}(2^n)$ 枚举 $\mathcal{O}(n^2)$ 查询，最终时间复杂度 $\mathcal{O}(2^nn^2)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXP = (<span class="number">1</span> &lt;&lt; MAXN) + <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    db x, y;</span><br><span class="line">    Point(db _x = <span class="number">0</span>, db _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> y * rhs.x &lt; rhs.y * x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, _;</span><br><span class="line"><span class="keyword">int</span> d[MAXP];</span><br><span class="line">Point pigs[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(db &amp;a, db &amp;b, db x1, db y1, db x2, db y2)</span> </span>&#123;</span><br><span class="line">    b = (y1 * x2 * x2 - y2 * x1 * x1) / x1 / x2 / (x2 - x1);</span><br><span class="line">    a = (y1 - b * x1) / x1 / x1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[MAXP], qhead = <span class="number">0</span>, qtail = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// bfs 加入新的状态</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[v] == INF) &#123;</span><br><span class="line">        d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">        q[qtail++] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    qhead = qtail = <span class="number">0</span>;</span><br><span class="line">    q[qtail++] = s;</span><br><span class="line">    <span class="keyword">while</span> (qhead != qtail) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q[qhead++];</span><br><span class="line">        <span class="keyword">if</span> (now == (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> d[now];</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>;  <span class="comment">// 当前第一只没有被打到的猪</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now; t &amp; <span class="number">1</span>; t &gt;&gt;= <span class="number">1</span>) p0++;</span><br><span class="line">        extend(now, now | (<span class="number">1</span> &lt;&lt; p0));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p0 + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            db a, b;</span><br><span class="line">            <span class="comment">// 极角排序后不能打出向上的曲线</span></span><br><span class="line">            <span class="keyword">if</span> (pigs[i].x + <span class="number">0.0001</span> &gt; pigs[p0].x)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 也不能是一条直线</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(pigs[i].x / pigs[i].y - pigs[p0].x / pigs[p0].y) &lt; eps)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            solve(a, b, pigs[p0].x, pigs[p0].y, pigs[i].x, pigs[i].y);</span><br><span class="line">            <span class="comment">// p0 和 i 代表的猪我们都打到了</span></span><br><span class="line">            <span class="keyword">int</span> to = now | (<span class="number">1</span> &lt;&lt; p0) | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="comment">// 找一找有没有恰好也被我们打到的猪</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                db delta = <span class="built_in">fabs</span>(a * pigs[j].x * pigs[j].x + b * pigs[j].x - pigs[j].y);</span><br><span class="line">                <span class="keyword">if</span> (delta &lt; eps) &#123;</span><br><span class="line">                    to |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            extend(now, to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_); _; _--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            db x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">            pigs[i] = Point(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(pigs, pigs + n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>抛物线<span style = "color:red">不能</span>是上凸的</li>
<li>抛物线<span style = "color:red">不能</span>是一条直线</li>
<li><p>要检查是否有本身不准备打但是最后经过了的猪</p>
</li>
<li><p>多组数据要清空</p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
        <tag>广度优先搜索bfs</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P4513 小白逛公园</title>
    <url>/2020/11/12/lg4513/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4513" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。  </p>
<p>一开始，小白就根据公园的风景给每个公园打了分-.-。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a$、$b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。  </p>
<p>那么，就请你来帮小白选择公园吧。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行，两个整数 $N$ 和 $M$，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。<br>    接下来 $N$ 行，每行一个整数，依次给出小白 开始时对公园的打分。<br>    接下来 $M$ 行，每行三个整数。第一个整数 $K$，$1$ 或 $2$。</p>
<ul>
<li>$K=1$ 表示，小新要带小白出去玩，接下来的两个整数 $a$ 和 $b$ 给出了选择公园的范围（$1≤a,b≤N$）。测试数据可能会出现 $a&gt;b$ 的情况，需要进行交换；</li>
<li>$K=2$ 表示，小白改变了对某个公园的打分，接下来的两个整数 $p$ 和 $s$，表示小白对第 $p$ 个公园的打分变成了 $s$($1\le p \le N$)。<br>  其中，$1\le N \le 5 \times 10^5$，$1 \le M \le 10^5$，所有打分都是绝对值不超过 $1000$ 的整数。  </li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p> 小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑一下不修改的做法，直接暴力跑一遍复杂度是 $\mathcal{O}(n)$ 的，不能直接去做。</p>
<p>维护一段区间的数据结构中，线段树无疑是一个很好的选择。</p>
<p>如果仍然采用暴力查询的方法，本质上复杂度并没有变优，想到朴素方法中只有与上一段相连和另起一段的情况，能否作为我们的解题思路呢？</p>
<p>这就涉及到了线段树上区间之间的合并（当然，单元素也是区间）</p>
<p>对于本题，一段中最大的子段有三种情况：</p>
<ol>
<li>最大的子段全部在本区间的右侧</li>
<li>最大的子段全部在本区间的左侧</li>
<li>最大的子段越过了本区间的中点</li>
</ol>
<p>注意到第三种情况一定是包含了本区间的一半，子区间的和是很好维护的，那么只要考虑另一半中选取开头的最大子段。（左区间从右到左的最大子段，右区间从左到右的最大子段）</p>
<p>本题也就被我们解决了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        ll ml, mr, mx, sum;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">    &#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll a[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        T[p].sum = T[ls].sum + T[rs].sum, T[p].ml = max(T[ls].ml, T[ls].sum + T[rs].ml),</span><br><span class="line">        T[p].mr = max(T[rs].mr, T[rs].sum + T[ls].mr),</span><br><span class="line">        T[p].mx = max(T[ls].mx, max(T[rs].mx, T[ls].mr + T[rs].ml));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        T[p].l = l, T[p].r = r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            T[p].sum = T[p].ml = T[p].mr = T[p].mx = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(l + r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        build(ls, l, mid);</span><br><span class="line">        build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T[p].l == T[p].r) &#123;</span><br><span class="line">            T[p].sum = T[p].ml = T[p].mr = T[p].mx = y;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(T[p].l + T[p].r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">            update(ls, x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update(rs, x, y);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= T[p].l &amp;&amp; T[p].r &lt;= r)</span><br><span class="line">            <span class="keyword">return</span> T[p];</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(T[p].l + T[p].r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(ls, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> query(rs, l, r);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node x = query(ls, l, r), y = query(rs, l, r), re;</span><br><span class="line">            re.sum = x.sum + y.sum;</span><br><span class="line">            re.ml = max(x.sum + y.ml, x.ml);</span><br><span class="line">            re.mr = max(y.sum + x.mr, y.mr);</span><br><span class="line">            re.mx = max(x.mx, max(y.mx, x.mr + y.ml));</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Tree T;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line">ll x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; T.a[i];</span><br><span class="line">    T.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">                swap(x, y);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; T.query(<span class="number">1</span>, x, y).mx &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T.update(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p>在本题中计算最终结果时需要用到左区间的最大子段、右区间的最大子段、左区间从右到左的最大子段、右区间从左到右的最大子段，因此要考虑直接返回一个结点</p>
</li>
<li><blockquote>
<p>测试数据可能会出现 $a&gt;b$ 的情况，需要进行交换</p>
</blockquote>
</li>
<li><p>没有区间修改可以不用加标记</p>
</li>
</ol>
<p>成功的解决了单点修改最大子段，来看看<a href="https://www.luogu.com.cn/problem/P4118" target="_blank" rel="noopener"><del>区间修改最大子段</del></a>吧。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1160 队列安排</title>
    <url>/2020/11/12/lg1160/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1160" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $ 1 \sim N$，他采取如下的方法：</p>
<ol>
<li>先将 $1$ 号同学安排进队列，这时队列中只有他一个人；</li>
<li>$2 \sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim (i -1)$ 中某位同学（即之前已经入列的同学）的左边或右边；</li>
<li>从队列中去掉 $M(M&lt;N)$ 个同学，其他同学位置顺序不变。</li>
</ol>
<p>在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行为一个正整数 $N$ ，表示了有 $N$ 个同学。</p>
<p>第 $2 \sim N$ 行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为00，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。</p>
<p>第 $N+1$ 行为一个正整数 $M$，表示去掉的同学数目。</p>
<p>接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 行，包含最多 $N$ 个空格隔开的正整数，表示了队列从左到右所有同学的编号，行末换行且无空格。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用双向链表模拟即可，注意不要写 <a href="https://www.luogu.com.cn/discuss/show/276680" target="_blank" rel="noopener">ub</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> k, p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    a[<span class="number">1</span>].l = <span class="number">0</span>, a[<span class="number">1</span>].r = <span class="number">100009</span>, a[<span class="number">0</span>].r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; p;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">            a[i].l = a[k].l, a[i].r = k, a[a[k].l].r = i, a[k].l = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[i].r = a[k].r, a[i].l = k, a[a[k].r].l = i, a[k].r = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (!v[k])</span><br><span class="line">            a[a[k].l].r = a[k].r, a[a[k].r].l = a[k].l, v[k] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bib = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bib = a[bib].r;</span><br><span class="line">        <span class="keyword">if</span> (bib != <span class="number">100009</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; bib &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>定义链表不存在中的元素时注意数组是否会越界</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>P1816 忠诚</title>
    <url>/2020/11/12/lg1816/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1816" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老管家是一个聪明能干的人。他为财主工作了整整 $10$ 年，财主为了让自已账目更加清楚。要求管家每天记 $k$ 次账，由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按 $1,2,3 \cdots$ 编号，然后不定时的问管家问题，问题是这样的：在 $a$ 到 $b$ 号账中最少的一笔是多少？为了让管家没时间作假他总是一次问多个问题。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入中第一行有两个数 $m,n$ 表示有 $m$($m \le 10^5$)笔账,$n$ 表示有 $n$ 个问题，$n \le 10^5$。</p>
<p>第二行为 $m$ 个数,分别是账目的钱数</p>
<p>后面 $n$ 行分别是 $n$ 个问题,每行有 $2$ 个数字说明开始结束的账目编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件中为每个问题的答案。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>当然可以用线段树来维护，但是这里选择树状数组会更加精炼</p>
<p>当然，树状数组也有其弊端，对于没有被包含的单个节点，就需要一个一个比较了……<span style="color:red">这会大大降低效率！</span> </p>
<p>upd: ST 表（这个会快很多，重点在于没有修改）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        树状数组
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> t[N], a[N];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[x] &gt; k)</span><br><span class="line">            t[x] = k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        x += x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">while</span> (y &gt;= x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y - (y &amp; -y) &gt; x) &#123;</span><br><span class="line">            r = min(r, t[y]);</span><br><span class="line">            y -= y &amp; -y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = min(r, a[y]);</span><br><span class="line">            --y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">127</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        add(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; getmin(x, y) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        线段树
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, op, x, y, k;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll min_p, sum, tag;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? b : a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(ll p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(ll p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    T[p].sum = T[ls(p)].sum + T[rs(p)].sum;</span><br><span class="line">    T[p].min_p = min(T[ls(p)].min_p, T[rs(p)].min_p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    T[p].tag = <span class="number">0</span>;</span><br><span class="line">    T[p].min_p = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        T[p].min_p = T[p].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls(p), l, mid);</span><br><span class="line">    build(rs(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    T[ls(p)].sum += T[p].tag * (r - l + <span class="number">1</span>);</span><br><span class="line">    T[ls(p)].tag += T[p].tag;</span><br><span class="line">    T[rs(p)].sum += T[p].tag * (r - l + <span class="number">1</span>);</span><br><span class="line">    T[rs(p)].tag += T[p].tag;</span><br><span class="line">    T[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query_min</span><span class="params">(ll q_x, ll q_y, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q_x &lt;= l &amp;&amp; r &lt;= q_y)</span><br><span class="line">        <span class="keyword">return</span> T[p].min_p;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>, resa = <span class="number">0x3f3f3f3f</span>, resb = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    push_down(p, l, r);</span><br><span class="line">    <span class="keyword">if</span> (q_x &lt;= mid)</span><br><span class="line">        resa = query_min(q_x, q_y, l, mid, ls(p));</span><br><span class="line">    <span class="keyword">if</span> (q_y &gt; mid)</span><br><span class="line">        resb = query_min(q_x, q_y, mid + <span class="number">1</span>, r, rs(p));</span><br><span class="line">    <span class="keyword">return</span> min(resa, resb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; query_min(x, y, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        ST 表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lg2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> result = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0xffff0000</span>) result += <span class="number">16</span>, n &gt;&gt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x0000ff00</span>) result += <span class="number">8</span>, n &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x000000f0</span>) result += <span class="number">4</span>, n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x0000000c</span>) result += <span class="number">2</span>, n &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x00000002</span>) result += <span class="number">1</span>, n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">25</span>][N], l, r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getcha();</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = -f;</span><br><span class="line">        ch = getcha();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getcha();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> pbuf[<span class="number">100000</span>], *pp = pbuf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp - pbuf == <span class="number">100000</span>)</span><br><span class="line">        fwrite(pbuf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdout</span>), pp = pbuf;</span><br><span class="line">    *pp++ = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sta[<span class="number">35</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sta[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">while</span> (top) push(sta[--top] + <span class="string">'0'</span>);</span><br><span class="line">    push(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) f[j][i] = min(f[j - <span class="number">1</span>][i], f[j - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        l = read(), r = read();</span><br><span class="line">        <span class="keyword">int</span> s = lg2(r - l + <span class="number">1</span>);</span><br><span class="line">        write(min(f[s][l], f[s][r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(pbuf, <span class="number">1</span>, pp - pbuf, <span class="built_in">stdout</span>);</span><br><span class="line">    pp = pbuf;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>要初始化为最大值</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>P3368 【模板】树状数组 2</title>
    <url>/2020/11/12/lg3368/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3368" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数数加上 $x$；</li>
<li>求出某一个数的值。</li>
</ol>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 $N$、$M$($1 \le N,M \le 5 \times 10^5$)，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $M$ 行每行包含 $2$ 或 $4$ 个整数，表示一个操作，具体如下：</p>
<p>操作 $1$： 格式：<code>1 x y k</code> 含义：将区间 $[x,y]$ 内每个数加上 $k$；</p>
<p>操作 $2$： 格式：<code>2 x</code> 含义：输出第 $x$ 个数的值。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 $2$ 的结果。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树状数组区间修改单点查询模板题，暂无</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N], x, y, k, op, n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) t[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res += t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x, add(i, x - y), y = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k, add(x, k), add(y + <span class="number">1</span>, -k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x, <span class="built_in">cout</span> &lt;&lt; ask(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>差分查询插入时要注意</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P3374 【模板】树状数组 1</title>
    <url>/2020/11/12/lg3374/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ul>
<li>将某一个数加上 $x$</li>
<li>求出某区间每一个数的和</li>
</ul>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n,m$($1 \le n,m \le 5 \times 10^5$)，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：</p>
<ul>
<li><code>1 x k</code> 含义：将第 $x$ 个数加上 $k$</li>
<li><code>2 x y</code> 含义：输出区间 $[x,y]$ 内每个数的和</li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 $2$ 的结果。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树状数组单点修改区间查询模板题，暂无</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N], op, x, y, n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) t[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res += t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x, add(i, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            add(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ask(y) - ask(x - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>前缀和查询是 $r$ 和 $l-1$</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P1106 删数问题</title>
    <url>/2020/11/12/lg1106/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1106" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>键盘输入一个高精度的正整数 $N$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $N$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>$n$（高精度的正整数 )。</p>
<p>$k$（需要删除的数字个数 )。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>最后剩下的最小数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，直接贪心删去最小的是错的，可以举出反例 $N = 1329, k = 1$ 时答案应该是 $129$ 而不是 $132$。</p>
<p>考虑去维护一个单调不减栈，每次入栈的时候进行判断，依次删去 $k$ 个不满足不减的元素，可以保证最后一定是最小</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">int</span> k, idx;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, s + <span class="number">1</span>, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( k &amp;&amp; sta.size() &amp;&amp; sta.top() &gt; <span class="number">0</span> &amp;&amp; s[i] - <span class="string">'0'</span> &lt; sta.top() ) sta.pop(), k--;</span><br><span class="line">        sta.push(s[i] - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k-- &amp;&amp; sta.size()) sta.pop();</span><br><span class="line">	<span class="keyword">while</span> (!sta.empty()) &#123;</span><br><span class="line">		ans[++idx] = sta.top();sta.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ans[idx] == <span class="number">0</span> &amp;&amp; idx) --idx;</span><br><span class="line">	<span class="keyword">if</span>(idx == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=idx;i&gt;=<span class="number">1</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>注意到第 11 行 <code>k &amp;&amp; sta.size() &amp;&amp; sta.top() &gt; 0 &amp;&amp; s[i] - &#39;0&#39; &lt; sta.top()</code> 中 <code>sta.size()</code> 和 <code>sta.top()</code> 不能反过来，否则 RE</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>赛前冲刺日志</title>
    <url>/2020/10/28/%E8%B5%9B%E5%89%8D%E5%86%B2%E5%88%BA%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>离 noip2020 一个多月的一点学习记录。</p>
<a id="more"></a>
<h2 id="2020-10-28"><a href="#2020-10-28" class="headerlink" title="2020.10.28"></a>2020.10.28</h2><ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3376" target="_blank" rel="noopener">P3376 【模板】网络最大流</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P6062" target="_blank" rel="noopener">P6062 [USACO05JAN]Muddy Fields G</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P3128" target="_blank" rel="noopener">P3128 [USACO15DEC]Max Flow P</a></p>
</li>
<li><a href="https://www.luogu.com.cn/problem/U64970" target="_blank" rel="noopener">U64970 車的放置</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">P3379 【模板】最近公共祖先（LCA）</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3258" target="_blank" rel="noopener">P3258 [JLOI2014]松鼠的新家</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5002" target="_blank" rel="noopener">P5002 专心OI - 找祖先</a></li>
<li><a href="https://www.luogu.com.cn/problem/P6869" target="_blank" rel="noopener">P6869 [COCI2019-2020#5] Putovanje</a></li>
</ul>
<p>今天的题前四道是二分图和网络流相关的，主要使用了 <a href="https://www.xht37.com/%e4%ba%8c%e5%88%86%e5%9b%be%e4%b8%8e%e7%bd%91%e7%bb%9c%e6%b5%81-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/" target="_blank" rel="noopener">xht37 的板子</a>，做的也还可以，难点在于二分图的建立和一些细节处理。后四道题是 LCA 和树上差分相关的题目，主要复习了倍增 LCA 的求法以及点差分转边差分，难点在于模型的转化和一些细节处理。 可见，图论的题最难的是建图，在实际使用中可以把最大流当做一个黑盒代码使用。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>最大流中两个 $n$ 的含义是不一样的，一个可能是行数而不是真正的点数</li>
<li>二分图中如果沿用 $n$ 应当注意，$n$ 是<strong>所有点</strong>的数量并非一个集合中点的数量</li>
<li>二分图中如果采用 Dinic，最后求和的时候一定要记得循环从 <code>for (int i = 1; i &lt;= n; i++) hi[i] = head[i];</code> 改为 <code>for (int i = 0; i &lt; T; i++) hi[i] = head[i];</code> </li>
<li>倍增求 LCA 时，应该将较大的开在第一维如 <code>f[N][25]</code></li>
<li>倍增求 LCA 时，判断条件中 <code>if (dep[f[x][i]] &gt;= dep[y])</code> 一定不要忘记是<strong>大于等于</strong></li>
<li>无向图建图应当开双向边</li>
<li>网络流最初从 $1$ 开始建边</li>
</ol>
<h2 id="2020-10-29"><a href="#2020-10-29" class="headerlink" title="2020.10.29"></a>2020.10.29</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P2590" target="_blank" rel="noopener">P2590 [ZJOI2008]树的统计</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">P3379 【模板】最近公共祖先（LCA）</a></li>
</ul>
<p>今天的题目与树链剖分有关，主要参考了 <a href="https://oi-wiki.org/graph/hld/" target="_blank" rel="noopener">oi wiki</a>。为什么今天只有两道题呢？……<span style="color:white;">因为树剖太难调了</span><br>树剖的常数很小，比倍增小很多。而且很适合用来统计树上问题，当然，要注意的地方也不少。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol>
<li>我们需要维护每个结点的父亲、深度、子树大小、重儿子、重链的头、节点的 dfs 序、dfs 对应的节点编号等</li>
<li>第二遍 dfs 的时候一定要记得两个参数都是 v</li>
<li>线段树查询的时候一定要用 <code>ql, qr</code> 作为参数，便于调试</li>
<li>可以考虑精简线段树，不需要用到的可以不写</li>
<li>线段树空间要开到四倍</li>
<li>初始的时候 <code>dep[1] = 1</code></li>
<li>求 LCA 时，一定是 <span style="color:red;"><code>if (dep[top[u]] &gt; dep[top[v]])</code> </span> 而不是 <code>if (dep[u] &gt; dep[v])</code> &lt;/span&gt;</li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        又臭又长的代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], x, y;</span><br><span class="line"><span class="keyword">int</span> n, m, root, tot, head[N], dep[N], siz[N], son[N], top[N], f[N], dfn[N], rnk[N], cnt;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum[N &lt;&lt; <span class="number">2</span>], tag[N &lt;&lt; <span class="number">2</span>], maxx[N &lt;&lt; <span class="number">2</span>], a[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; sum[p] = sum[ls(p)] + sum[rs(p)], maxx[p] = max(maxx[ls(p)], maxx[rs(p)]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            maxx[p] = sum[p] = a[rnk[l]];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(l + r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        build(ls(p), l, mid);</span><br><span class="line">        build(rs(p), mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; qr || r &lt; ql)</span><br><span class="line">            <span class="keyword">return</span> -inf;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> maxx[p];</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(l + r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> max(query1(ls(p), l, mid, ql, qr), query1(rs(p), mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; qr || r &lt; ql)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> sum[p];</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(l + r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> query2(ls(p), l, mid, ql, qr) + query2(rs(p), mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            maxx[p] = sum[p] = t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">(l + r &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">            update(ls(p), l, mid, x, t);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update(rs(p), mid + <span class="number">1</span>, r, x, t);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[++tot] = v;</span><br><span class="line">    nxt[tot] = head[u];</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    son[u] = <span class="number">-1</span>, siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!dep[v]) &#123;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            f[v] = u;</span><br><span class="line">            dfs1(v);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (son[v] == <span class="number">-1</span> || siz[v] &gt; siz[son[u]])</span><br><span class="line">                son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tv)</span> </span>&#123;</span><br><span class="line">    top[x] = tv;</span><br><span class="line">    dfn[x] = ++cnt;</span><br><span class="line">    rnk[cnt] = x;</span><br><span class="line">    <span class="keyword">if</span> (son[x] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], tv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (v != f[x] &amp;&amp; v != son[x])</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querymax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -inf, fx = top[x], fy = top[y];</span><br><span class="line">    <span class="keyword">while</span> (fx != fy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fx] &gt;= dep[fy])</span><br><span class="line">            ret = max(ret, T.query1(<span class="number">1</span>, <span class="number">1</span>, n, dfn[fx], dfn[x])), x = f[fx];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = max(ret, T.query1(<span class="number">1</span>, <span class="number">1</span>, n, dfn[fy], dfn[y])), y = f[fy];</span><br><span class="line">        fx = top[x];</span><br><span class="line">        fy = top[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] &lt; dfn[y])</span><br><span class="line">        ret = max(ret, T.query1(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y]));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = max(ret, T.query1(<span class="number">1</span>, <span class="number">1</span>, n, dfn[y], dfn[x]));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fx = top[x], fy = top[y];</span><br><span class="line">    <span class="keyword">while</span> (fx != fy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fx] &gt;= dep[fy])</span><br><span class="line">            ret += T.query2(<span class="number">1</span>, <span class="number">1</span>, n, dfn[fx], dfn[x]), x = f[fx];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret += T.query2(<span class="number">1</span>, <span class="number">1</span>, n, dfn[fy], dfn[y]), y = f[fy];</span><br><span class="line">        fx = top[x];</span><br><span class="line">        fy = top[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] &lt; dfn[y])</span><br><span class="line">        ret += T.query2(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret += T.query2(<span class="number">1</span>, <span class="number">1</span>, n, dfn[y], dfn[x]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y);</span><br><span class="line">        add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T.a[i]);</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    T.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">"CHANGE"</span>))</span><br><span class="line">            T.update(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], y);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">"QMAX"</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, querymax(x, y));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">"QSUM"</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, querysum(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="2020-10-30"><a href="#2020-10-30" class="headerlink" title="2020.10.30"></a>2020.10.30</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P2680" target="_blank" rel="noopener">P2680 运输计划</a></li>
</ul>
<p>一道题还没做完（</p>
<p>这个题本来自信能 20pts，结果 15 pts，调了一会找不到错误，于是看了看数据发现<span style="color:red;"><strong>查询的起点和终点是一个点</strong></span>……</p>
<p>在网上找不到想要的暴力做法，明天可能会自己写一个 60pts 的</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code_20pts
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>, M = N * <span class="number">2</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> tot, to[M], cost[M], nxt[M], head[N], dep[N], f[N][<span class="number">25</span>], d[N], rnk[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    to[++tot] = v;</span><br><span class="line">    nxt[tot] = head[u];</span><br><span class="line">    cost[tot] = w;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[u]; i++) f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y])</span><br><span class="line">            x = f[x][i];</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        calc(v, u);</span><br><span class="line">        d[u] += d[v];</span><br><span class="line">        rnk[v] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    q.reserve(<span class="number">3005</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        q.push_back(make_pair(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!q.empty());</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q[<span class="number">0</span>].first, y = q[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0"</span>),<span class="number">0</span>; <span class="comment">// 这个点是真的毒瘤</span></span><br><span class="line">        d[x]++, d[y]++, d[lca(x, y)] -= <span class="number">2</span>;</span><br><span class="line">        calc(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxx = -inf, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                maxx = max(maxx, cost[rnk[i]]);</span><br><span class="line">                ans += cost[rnk[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans - maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ol>
<li>查询起点和终点的是同一个点要记得特判</li>
<li><code>calc</code> 中是 <code>rnk[v] = i;</code> 不是 <code>rnk[u] = i;</code></li>
</ol>
<p>打了 <a href="https://codeforces.ml/contest/1422" target="_blank" rel="noopener">Codeforces Round #675 (Div. 2)</a> ：</p>
<ol>
<li><a href="https://codeforces.ml/contest/1422/problem/A" target="_blank" rel="noopener">Fence</a></li>
<li><a href="https://codeforces.ml/contest/1422/problem/B" target="_blank" rel="noopener">Nice Matrix</a></li>
<li><a href="https://codeforces.ml/contest/1422/problem/C" target="_blank" rel="noopener">Bargain</a></li>
<li><a href="https://codeforces.ml/contest/1422/problem/D" target="_blank" rel="noopener">Returning Home</a></li>
<li><a href="https://codeforces.ml/contest/1422/problem/E" target="_blank" rel="noopener">Minlexes</a></li>
</ol>
<h2 id="2020-10-31"><a href="#2020-10-31" class="headerlink" title="2020.10.31"></a>2020.10.31</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P3150" target="_blank" rel="noopener">P3150 pb的游戏（1）</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1305" target="_blank" rel="noopener">P1305 新二叉树</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4710" target="_blank" rel="noopener">P4710 「物理」平抛运动</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3373" target="_blank" rel="noopener">P3373 【模板】线段树 2</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener">P3865 【模板】ST表</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener">P3808 【模板】AC自动机（简单版）</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener">P3384 【模板】轻重链剖分</a></li>
</ul>
<p>可以看到，除了三道题是来自原来的任务列表以外，做了四道模板题，按照熟练程度由大到小排序。</p>
<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><ol>
<li><strong>空间要开四倍</strong></li>
<li>下推标记时先加法后乘法</li>
</ol>
<h4 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h4><ol>
<li>考虑线性求 log <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logn[<span class="number">1</span>] = <span class="number">0</span>,Logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        Logn[i] = Logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><ol>
<li>应当考虑写个函数 <code>rnk</code> 用来求 <code>str[i] - &#39;a&#39;</code>  ，避免 <code>i</code> 和 <code>idx</code> 两个变量混用</li>
</ol>
<h2 id="2020-11-1"><a href="#2020-11-1" class="headerlink" title="2020.11.1"></a>2020.11.1</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1311" target="_blank" rel="noopener">P1311 选择客栈</a></li>
<li><a href="https://codeforces.ml/contest/1445" target="_blank" rel="noopener">Codeforces Round #680 (Div. 2, based on Moscow Team Olympiad)</a><ul>
<li><a href="https://codeforces.ml/contest/1445/problem/A" target="_blank" rel="noopener">Array Rearrangment</a></li>
<li><a href="https://codeforces.ml/contest/1445/problem/B" target="_blank" rel="noopener">Elimination</a></li>
<li><a href="https://codeforces.ml/contest/1445/problem/C" target="_blank" rel="noopener">Division</a></li>
<li><a href="https://codeforces.ml/contest/1445/problem/D" target="_blank" rel="noopener">Divide and Sum</a></li>
</ul>
</li>
</ul>
<h2 id="2020-11-2-11-4"><a href="#2020-11-2-11-4" class="headerlink" title="2020.11.2~11.4"></a>2020.11.2~11.4</h2><p>sb文化课+月考（</p>
<h2 id="2020-11-5"><a href="#2020-11-5" class="headerlink" title="2020.11.5"></a>2020.11.5</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最近公共祖先</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>倍增</tag>
        <tag>重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 677 (Div. 3)</title>
    <url>/2020/10/21/cf1433/</url>
    <content><![CDATA[<h2 id="A-Boring-Apartments"><a href="#A-Boring-Apartments" class="headerlink" title="A.Boring Apartments"></a><a href="https://codeforces.com/contest/1433/problem/A" target="_blank" rel="noopener">A.Boring Apartments</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一座建筑物由 $10000$ 套公寓组成，编号从 $1$ 到 $10000$，包括 $1,10000$。</p>
<p>如果一个公寓的号码是由<em>相同的数字</em>组成的，则称它<strong>无聊</strong>。无聊公寓的例子有 $11,2,777,9999$ 等等。</p>
<p>我们的主角是个捣蛋鬼，他给所有无聊公寓的对讲机打电话，直到有人接电话，顺序如下:</p>
<ul>
<li>首先，他以递增的次序呼叫所有由数字 $1$ 组成的公寓($1,11,111,1111$)</li>
<li>接下来，他以递增的次序呼叫所有由数字 $2$ 组成的公寓($2,22,222,2222$)</li>
<li>诸如此类。</li>
</ul>
<p>无聊公寓的住户 $x$ 接听了电话，我们的角色不再给任何人打电话。</p>
<p>我们的主角想知道他总共按了多少个数字，而你的任务就是帮助他计算按键的总数。</p>
<p>例如，如果无聊公寓 $22$ 的居民回答，那么我们的字符称为公寓 $1,11,111,111,2,22$，他按下的总数字是 $1 + 2 + 3 + 4 + 1 + 2 = 13$。</p>
<a id="more"></a>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数 $t$ ($1\leq t \leq3 6$)为测试用例数。</p>
<p>每组数据中唯一的一行输入包含一个整数 $x$($1\leq x \leq 9999$)，表示接电话的居民的公寓号。保证 $x$ 由相同的数字组成。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例，打印出答案: 我们的主角总共按了多少个数字。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑到打到 $x$ 时，前面的所有数字的所有号码都被打了一遍即 $(c-1) \times 10$,其中 $c = x \bmod 10$。</p>
<p>当前这个数字被打了 $\dfrac {(cnt+1) \times cnt}{2}$，其中 $cnt$ 为 $x$ 的位数 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, m = n;</span><br><span class="line">    <span class="keyword">while</span> (m) &#123;</span><br><span class="line">        m /= <span class="number">10</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = n % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = (cnt + <span class="number">1</span>) * cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (c - <span class="number">1</span>) * <span class="number">10</span> + ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_); _; _--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Yet-Another-Bookshelf"><a href="#B-Yet-Another-Bookshelf" class="headerlink" title="B.Yet Another Bookshelf"></a><a href="https://codeforces.com/contest/1433/problem/B" target="_blank" rel="noopener">B.Yet Another Bookshelf</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个可以放下 $n$ 本书的书架。如果第 $i$ 个位置上有一本书，则 $a_i=1$，否则 $a_i=0$。保证书架上至少有一本书。</p>
<p>在一步中，你可以移动一些连续的段 $[l,r]$ 组成的图书(也就是说，对于每个 $i$ 从 $ l$ 到 $r$，满足 $a_i=1$)：</p>
<ul>
<li>把它移到右边 $1$ 个：把所有的 $i(l\leq i\leq r)$ 号书移到 $i+1$  。前提是当 $r+1 \leq n$ 而且 $r+1$ 上没有书</li>
<li>把它移到左边 $1$ 个：把所有的 $i(l \leq i \leq r)$ 号书移到 $i-1$  。前提是当 $l-1 \leq n$ 而且 $r+1$ 上没有书</li>
</ul>
<p>你的任务是找到一段连续的(即没有任何间隙的段)来收集书架上所有书籍所需的最小移动次数。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数 $t$($1≤ t ≤200$)为测试用例数。</p>
<p>测试用例的第一行包含一个整数 $n$($1≤ n ≤50$)书架上的位置数。测试用例的第二行包含 $n$ 个整数 $a_1,a_2,\ldots,a_n$($0 \le a_i \le 1$) ，其中如果在这个位置有一本书，则 $a_i$ 为 $1$，否则为 $0$。保证书架上<strong>至少有一本书</strong>。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例，输出一个整数：用连续段(即没有间隙的段)收集书架上所有书所需的最小移动次数。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果有两个段作为不连续的段，它们之间的空隙我们总可以一步完成。</p>
<p>那么对于每一个记录的段，求出它与下一个段的长度，最后将这些 “空隙”长度加起来就是我们的答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _, n, a[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span> &amp;&amp; !last) &#123;</span><br><span class="line">            last = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += i - last - <span class="number">1</span>;</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_); _; _--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Dominant-Piranha"><a href="#C-Dominant-Piranha" class="headerlink" title="C.Dominant Piranha"></a><a href="https://codeforces.com/contest/1433/problem/C" target="_blank" rel="noopener">C.Dominant Piranha</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>水族馆里有 $n$ 条大小分别为 $a_1, a_2, \ldots, a_n$ 的食人鱼，按照生活在水族馆的顺序从左到右编号。</p>
<p>伯兰州立大学的科学家们想要找出水族馆里是否有占优势的食人鱼。如果食人鱼能吃掉水族馆里所有的其他食人鱼(当然，除了它自己) ，它就被称为优势食人鱼。其他的食人鱼什么也不会做，而占优势的食人鱼会吃掉它们。</p>
<p>由于水族馆相当狭长，食人鱼在一次移动中只能吃掉邻近的一条食人鱼。食人鱼可以根据自己的需要(或尽可能)做任何动作。更确切地说:</p>
<ul>
<li>食人鱼 $i$ 可以吃食人鱼 $i-1$ 当且仅当 $a_{i-1}&lt;a_i$ </li>
<li>食人鱼 $i$ 可以吃食人鱼 $i+1$ 当且仅当 $a_{i+1}&lt;a_i$ </li>
</ul>
<p>在 $i$ 号食人鱼吃掉一条鱼后，它的体积会增大一 ($a_i \to a_i+1$)</p>
<p>你要找到占优势的任意一条食人鱼，如果没有，输出 $-1$</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数 $t$($1 \le t \le 2 \cdot 10^4$)为测试用例数。</p>
<p>测试用例的第一行包含一个整数 $n$($2 \le n \le 3 \cdot 10^5$)水族馆里食人鱼的数量。测试用例的第二行包含 $n$ 个整数 $a_1,a_2,\ldots,a_n$($1 \le a_i \le 10^9$) 。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例：如果没有一条占优势的鱼输出 $-1$，否则输出任意一条优势鱼的编号</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>无解的情况很好判断，也就是全部相等。对于其他的情况，总是能确定一个唯一最大值（也可能是吃掉鱼后的唯一最大）。我的这个做法的正确性不能保证，是通过找到最大和次大两个进行判断的，不确定有没有数据能够卡掉 = =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> _, n, a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>, flag = <span class="number">1</span>, maxx = a[<span class="number">1</span>], idx = <span class="number">1</span>, max2, idx2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != a[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (maxx &lt; a[i]) &#123;</span><br><span class="line">                max2 = maxx, idx2 = idx;</span><br><span class="line">                maxx = a[i], idx = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxx &gt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == maxx) &#123;</span><br><span class="line">                    max2 = maxx, idx2 = idx;</span><br><span class="line">                    maxx = a[i - <span class="number">1</span>], idx = i - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i + <span class="number">1</span>] == maxx) &#123;</span><br><span class="line">                    max2 = maxx, idx2 = idx;</span><br><span class="line">                    maxx = a[i + <span class="number">1</span>], idx = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx - <span class="number">1</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[idx - <span class="number">1</span>] &lt; maxx) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, idx);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (idx + <span class="number">1</span> &lt;= n &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[idx + <span class="number">1</span>] &lt; maxx) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, idx);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx2 + <span class="number">1</span> &lt;= n &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[idx2 + <span class="number">1</span>] &lt; max2) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, idx2);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx2 - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[idx2 - <span class="number">1</span>] &lt; max2) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, idx2);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_); _; _--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>不应该写成 <code>a[idx-1]&lt;maxx&amp;&amp;a[idx-1]&gt;=1</code> 可能访问负数下标</li>
</ol>
<h2 id="D-Districts-Connection"><a href="#D-Districts-Connection" class="headerlink" title="D. Districts Connection"></a><a href="https://codeforces.com/contest/1433/problem/D" target="_blank" rel="noopener">D. Districts Connection</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>城市有 $n$ 个区域，第 $i$ 个区域属于 $a_i$ 号帮派，最初没有区域互相连接。</p>
<p>你的任务是建立 $n-1$ 条双向边使得区域间相互连通，任意一条边的两端不属于同一个帮派。</p>
<h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数 $t$($1 \le t \le 500$)为测试用例数。</p>
<p>测试用例的第一行包含一个整数 $n$($2 \le n \le 5000$)区域的数量。测试用例的第二行包含 $n$ 个整数 $a_1,a_2,\ldots,a_n$($1 \le a_i \le 10^9$)表示 $i$ 号区域的归属 。</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个测试用例：</p>
<ul>
<li><p>如果不能连接输出一行字符串 <code>NO</code></p>
</li>
<li><p>如果可以连接输出一行字符串 <code>YES</code>，接下来 $n-1$ 行分别输出 $n-1$ 条边，用点对 $x_i$ 和 $y_i$($1 \le x_i, y_i \le n; x_i \ne y_i$)表示。 </p>
</li>
</ul>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>无解的情况很好判断，也就是全部相等。考虑至少有两个帮派的情况，将所有非 $a_1$ 的帮派控制的区域与 $a_1$ 相连，找到最后一个与 $a_1$ 相连的区域，将所有 $a_1$ 帮派控制的区域与其相连。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) &#123; x = _x, y = _y; &#125;</span><br><span class="line">&#125; p[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> _, n, a[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, flag = <span class="number">1</span>, idx, idx2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != a[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != a[<span class="number">1</span>])</span><br><span class="line">                p[++cnt] = &#123; <span class="number">1</span>, i &#125;, idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[<span class="number">1</span>])</span><br><span class="line">                p[++cnt] = &#123; idx, i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p[i].x, p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_); _; _--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol>
<li>构造函数必须先考虑无参构造，否则会报错</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>P4170 [CQOI2007]涂色</title>
    <url>/2020/10/21/lg4170/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4170" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你有一条长度为 $5$ 的木版，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：<code>RGBGR</code>。</p>
<p>每次你可以把一段连续的木版涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木版涂成 <code>RRRRR</code>，第二次涂成 <code>RGGGR</code>，第三次涂成 <code>RGBGR</code>，达到目标。</p>
<p>用尽量少的涂色次数达到目标。</p>
<a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。($1≤n≤50$)</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，包含一个数，即最少的涂色次数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>初始为空，要达到最终状态，我们总是需要选择<strong>一段</strong>涂上颜色。可以很快想到用区间 $\text{DP}$。</p>
<p>考虑这么一个问题，若给定状态中只用涂上一个字符，我们一定只用涂一次。这也就是边界条件 $f_{i,i}=1$。</p>
<p>而对于颜色相同而非同一个字符的情况，多涂一个总是无伤大雅的，也就是 $f<em>{i,j}=\min(f</em>{i+1,j},f_{i,j-1})$。</p>
<p>总后也就是我们常用的区间 $\text{DP}$，枚举一个分割点进行 $\text{DP}$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[l][r]  = 	min&#123; f[l + 1][r], f[l][r - 1] &#125;(a[l] = a[r]),</span></span><br><span class="line"><span class="comment">		min&#123; f[l][k] + f[k + 1][r], f[l][r] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; length; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len &lt;= length; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + len;</span><br><span class="line">            <span class="keyword">if</span> (a[l] == a[r])</span><br><span class="line">                f[l][r] = min(f[l + <span class="number">1</span>][r], f[l][r - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++) f[l][r] = min(f[l][k] + f[k + <span class="number">1</span>][r], f[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">1</span>][length]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P6832 [Cnoi2020]子弦</title>
    <url>/2020/10/20/lg6382/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6832" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Cirno 有一个字符串 $\texttt{S}$，并希望你能求出 $\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。</p>
<a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，一个字符串 $\texttt{S}$。($0 &lt; | \texttt{S} | \le 10^7$,$\texttt{S}_x\in [ \texttt{a} , \texttt{z} ]$)</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，一个整数 $p$。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于长度为一符串，有且仅有一个子串为最大。对于长度大于一的字符串的子串，总包含了单个字母为子串，也就保证了单个字母作为子串总是最大的，因此，只用统计单个字母出现的最大次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ans, a[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        a[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        ans = max(ans, a[s[i] - <span class="string">'a'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>初赛复习集合</title>
    <url>/2020/10/07/%E5%88%9D%E8%B5%9B%E5%A4%8D%E4%B9%A0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>初赛过了</p>
</blockquote>
<a id="more"></a>
<h2 id="CSP-S-2019"><a href="#CSP-S-2019" class="headerlink" title="CSP/S-2019"></a>CSP/S-2019</h2><p><img src="https://i.loli.net/2020/10/07/XGtg8WTaAPBIY62.png" alt="image-20201007220800359"></p>
<p>​    Dijkstra 需要选取最近的 <code>d[s]</code>，Floyd 不需要任何贪心，Prim 同 Dijkstra，Kruskal 需要选取最短的边</p>
<p><img src="https://i.loli.net/2020/10/07/ulo9sYA4c3MTkhF.png" alt="image-20201007224328405"></p>
<p>第 4 题中，如果给定 $a=b$，那么 <code>cnt[i]</code> 会变成原先的两倍可能会超出 $n$<br>第 6 题中，要知道并查集不带路径压缩的最坏时间复杂度是 $\mathcal O(n)$ 的，那么执行 $n$ 次也就是 $\mathcal O(n^2)$ 的</p>
<h2 id="模拟题自测"><a href="#模拟题自测" class="headerlink" title="模拟题自测"></a>模拟题自测</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、下列说法错误的是（）。</span><br><span class="line">A、栈和队列的存储方式既可是顺序方式，也可是链式方式</span><br><span class="line">B、线性表在物理存储空间中不一定是连续的</span><br><span class="line">C、二叉树中每个节点的两棵子树高度差为1</span><br><span class="line">D、对于一棵非空二叉树，它的根节点作为第一层，则第i层至多有2^(i-1)个节点</span><br></pre></td></tr></table></figure>
<p>​    显然选 C，因为很容易举出反例。</p>
<p><img src="https://i.loli.net/2020/10/09/rYGOepZQksqN68m.png" alt="image-20201009004906424"></p>
<p><code>memset(a,255,sizeof(a))</code> 等价于将 a 全部赋值为 $-1$ </p>
<h2 id="一些知识点总结"><a href="#一些知识点总结" class="headerlink" title="一些知识点总结"></a>一些知识点总结</h2><h3 id="局域网、城域网、广域网、个人局域网"><a href="#局域网、城域网、广域网、个人局域网" class="headerlink" title="局域网、城域网、广域网、个人局域网"></a>局域网、城域网、广域网、个人局域网</h3><ul>
<li>LAN：局域网</li>
<li>MAN：城域网</li>
<li>WAN：广域网</li>
<li>PAN：个人局域网</li>
</ul>
<p>RAM 中的信息是 <strong>计算机工作时随机写入的</strong>（NOIP2000 普及）</p>
<p>用静电吸附墨粉后转移到纸张上，是 <strong>激光打印机</strong> 的工作方式（NOIP 2004）</p>
<p>彩色图像以位图形式保存时，若色深为 $n$，分辨率为 $x \times y$，则为 $n \times x \times y$ bit</p>
<ul>
<li>1B=8bit</li>
<li>1KB=1024B</li>
<li>1MB=1024KB</li>
<li>1GB=1024MB</li>
<li>1TB=1024GB</li>
</ul>
<h3 id="二叉树的若干性质"><a href="#二叉树的若干性质" class="headerlink" title="二叉树的若干性质"></a>二叉树的若干性质</h3><ul>
<li>在二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点（$i \ge 1$）</li>
<li>深度为 $k$ 的二叉树至多有 $2^{k} - 1$ 个结点（满二叉树）</li>
<li>对于任意一棵二叉树，如果其叶结点数为 $n_0$，而度数为 $2$ 的结点总数为 $n_2$，则有 $n_0=n_2+1$</li>
<li>具有 $n$ 个结点的完全二叉树的深度为 $\lfloor \log_2n \rfloor+1$</li>
</ul>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>前序遍历：根结点 左子树 右子树<br>中序遍历：左子树 根结点 右子树<br>后序遍历：左子树 右子树 根结点</p>
<h4 id="知前序、中序"><a href="#知前序、中序" class="headerlink" title="知前序、中序"></a>知前序、中序</h4><p>前序：ABCDEFG<br>中序：CBEDAFG<br>前序找到 A 为根，在中序中找到左子树 BCDE、右子树 FG<br>前序找到 B 为根，在中序中找到左子树 C、右子树 DE<br>前序找到 D 为根，在中序中找到左子树 E、无右子树<br>前序找到 F 为根，在中序中找到右子树 G、无左子树</p>
<p><img src="https://i.loli.net/2020/10/09/9xLqbzh7PcndkaG.png" alt="image-20201009012139226"></p>
<h4 id="知后序、中序"><a href="#知后序、中序" class="headerlink" title="知后序、中序"></a>知后序、中序</h4><p>后序：ABFHGEDC<br>中序：ABCEFGHD<br>后序找到 C 为根，在中序中找到左子树 AB、右子树 EFGHD<br>后序找到 B 为根，在中序中找到左子树 A、无右子树<br>后序找到 D 为根，在中序中找到左子树 EFGH、无右子树<br>后序找到 E 为根，在中序中找到右子树 FGH、无左子树<br>后序找到 G 为根，在中序中找到左子树 F、右子树 H</p>
<p><img src="https://i.loli.net/2020/10/09/35YxNhmUeLFvgWr.png" alt="image-20201009012850075"></p>
<h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><script type="math/tex; mode=display">
P_n^k=\dfrac{n!}{(n-k)!}\\
C_{n}^{k}=\binom{n}{k}=\dfrac{P_{n}^{k}}{P_{k}^{k}}=\dfrac{n!}{k!(n-k)!}\\
S(n,m)=\begin {Bmatrix} n \\ m\end {Bmatrix}={\frac 1 {m!}}\sum_{k=0}^m (-1)^k\binom{m}{k}(m-k)^n \\</script><script type="math/tex; mode=display">
{\binom{7}{2}}</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>初赛</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>P1535 【[USACO08MAR]Cow Travelling S】</title>
    <url>/2020/10/06/lg1535/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1535" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​    给定两点 $(x_1,y_1),(x_2,y_2)$，规定不超过 $t$ 步求从第一个点到第二个点的路径条数。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    看上去就能搜，问题是超时是无法避免的，重点在于考虑如何优化。</p>
<p>​    这里提供一个看似无关紧要但卡常很实用的范围判断优化。对于判断 $x \in [l,r]$，一种常规写法是 <code>l&lt;=x&amp;&amp;x&lt;=r</code>，实际上有更快的写法是 <code>(x-l)|(r-x)&gt;=0</code>，具体原理可以参考<a href="https://www.zhihu.com/question/27417946/answer/1253126563" target="_blank" rel="noopener">韦易笑的知乎回答</a>、<a href="https://zhuanlan.zhihu.com/p/147039093" target="_blank" rel="noopener">回答2</a>。</p>
<p>​    但是，即便是加上这个优化，也仅仅从 40 到了 50，并没有满足我们的要求。</p>
<p>​    考虑一个可行性剪枝，也就是考虑当前剩余步数不足以到达终点时，直接跳出，也就可以AC了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, t, sa, sb, ea, eb, ans;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">bool</span> okk[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == ea &amp;&amp; y == eb &amp;&amp; cur == <span class="number">0</span>)</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">if</span> (!cur || <span class="built_in">abs</span>(ea - x) + <span class="built_in">abs</span>(eb - y) &gt; cur)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = dx[i] + x, yy = dy[i] + y;</span><br><span class="line">        <span class="keyword">if</span> (okk[xx][yy])</span><br><span class="line">            dfs(xx, yy, cur - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'.'</span> &amp;&amp; ((i - <span class="number">1</span>) | (n - i) | (j - <span class="number">1</span>) | (m - j)) &gt;= <span class="number">0</span>)</span><br><span class="line">                okk[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sa &gt;&gt; sb &gt;&gt; ea &gt;&gt; eb;</span><br><span class="line">    dfs(sa, sb, t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>深度优先搜索dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>Aha-Round-1</title>
    <url>/2020/08/18/Aha-Round-1/</url>
    <content><![CDATA[<blockquote>
<p>团队要走的路还很远啊……</p>
</blockquote>
<a id="more"></a>
<h2 id="Pj"><a href="#Pj" class="headerlink" title="Pj"></a>Pj</h2><h3 id="T1-IOI-AKer"><a href="#T1-IOI-AKer" class="headerlink" title="T1 IOI AKer"></a>T1 <a href="https://www.luogu.com.cn/problem/T143359" target="_blank" rel="noopener">IOI AKer</a></h3><p>​    本场签到题，AC 占比 $\dfrac{13}{16}$ </p>
<p>​    很简单的字符串模拟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">"dbxxx"</span>||s==<span class="string">"DBXXX"</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" csl /weak"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" AK IOI! /strong"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2-清理收藏夹"><a href="#T2-清理收藏夹" class="headerlink" title="T2 清理收藏夹"></a>T2 <a href="https://www.luogu.com.cn/problem/T143360" target="_blank" rel="noopener">清理收藏夹</a></h3><p>​    很繁琐，赛时最高 14，最低 4 分，得分占比 $\dfrac{3}{16}$</p>
<p>​    先来吐槽一下题面，看上去很花，很大程度上让人不太想开这道题，细节也颇多，作为 pjT2 是彻底失败的。但是出题人 dbxxx 还是下了很大力气的。</p>
<h3 id="T3-巧克力机器"><a href="#T3-巧克力机器" class="headerlink" title="T3 巧克力机器"></a>T3 <a href="https://www.luogu.com.cn/problem/T143361" target="_blank" rel="noopener">巧克力机器</a></h3><p>​    有趣的区间 $\text{DP}$,比赛没来得及做。</p>
<h3 id="T4-加工伸缩门"><a href="#T4-加工伸缩门" class="headerlink" title="T4 加工伸缩门"></a>T4 <a href="https://www.luogu.com.cn/problem/T143362" target="_blank" rel="noopener">加工伸缩门</a></h3><p>​    组合数学神仙题，建议膜拜出题人：dbxxx</p>
<p><a href="https://www.luogu.com.cn/paste/pmgqz97r" target="_blank" rel="noopener">Pj题解</a>。</p>
<h2 id="Tg"><a href="#Tg" class="headerlink" title="Tg"></a>Tg</h2><h3 id="T1-function"><a href="#T1-function" class="headerlink" title="T1 function"></a>T1 <a href="https://www.luogu.com.cn/problem/T143365" target="_blank" rel="noopener">function</a></h3><p>​    有趣的数学题，数据范围对于这种题是没有意义的，所以直接上 python，不打高精了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=input()</span><br><span class="line">a=int(s.split(<span class="string">" "</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span>(a%<span class="number">3</span>!=<span class="number">0</span>) :</span><br><span class="line">    print(<span class="string">"Aha"</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(a//<span class="number">3</span>,<span class="string">""</span>,end=<span class="string">""</span>)</span><br><span class="line">    print(a//<span class="number">3</span>,<span class="string">""</span>,end=<span class="string">""</span>)</span><br><span class="line">    print(a//<span class="number">3</span>+a-a//<span class="number">3</span>*<span class="number">3</span>,end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<h3 id="T2-￥"><a href="#T2-￥" class="headerlink" title="T2 ￥"></a>T2 <a href="https://www.luogu.com.cn/problem/T143364" target="_blank" rel="noopener">￥</a></h3><p>​    状压 $\text{DP}$,不会（</p>
<h3 id="T3-绝世唐门"><a href="#T3-绝世唐门" class="headerlink" title="T3 绝世唐门"></a>T3 <a href="https://www.luogu.com.cn/problem/T143363" target="_blank" rel="noopener">绝世唐门</a></h3><p>​    毒瘤图论，不过用到的算法不太复杂。</p>
<p><a href="https://www.luogu.com.cn/paste/cqsgmh8g" target="_blank" rel="noopener">Tg题解</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    大家的参赛热情都很高，题目质量也很好，一些关键的细节把握不到位，作为一个新生团队，已经是很不错的水平了。</p>
<blockquote>
<p>Gar：多练可破。</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
        <tag>状压DP</tag>
        <tag>高精度</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
        <tag>广度优先搜索bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假线下集训总结</title>
    <url>/2020/08/01/%E6%9A%91%E5%81%87%E7%BA%BF%E4%B8%8B%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    中考完第二天就开始了集训，说实话，是既兴奋又紧张。一切似乎都是新的，让第二次来的我充满新鲜感（<del>第一天不知道机房位置，还是跟着同学去的</del>）。</p>
<a id="more"></a>
<h2 id="集训中的感想"><a href="#集训中的感想" class="headerlink" title="集训中的感想"></a>集训中的感想</h2><p>​    身边都是很优秀的同龄人，在一起刷题感到很有斗志，果然在学校刷题和在家里刷题是完全不同的。</p>
<h2 id="部分题目总结"><a href="#部分题目总结" class="headerlink" title="部分题目总结"></a>部分题目总结</h2><h3 id="真题练习（2020-7-22）"><a href="#真题练习（2020-7-22）" class="headerlink" title="真题练习（2020.7.22）"></a>真题练习（2020.7.22）</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1563" target="_blank" rel="noopener"><strong>P1563</strong> 玩具谜题</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2615" target="_blank" rel="noopener"><strong>P2615</strong> 神奇的幻方</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3958" target="_blank" rel="noopener"><strong>P3958</strong> 奶酪</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1328" target="_blank" rel="noopener"><strong>P1328</strong> 生活大爆炸版石头剪刀布</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2822" target="_blank" rel="noopener"><strong>P2822</strong> 组合数问题</a></p>
<p>这五道题是第一天的练手题，也是历年的真题，难度在接受范围以内，我之前除第五题都做过。</p>
<p>第五题还没有做，先 gugugu</p>
</li>
</ul>
<h3 id="单调队列（2020-7-22）"><a href="#单调队列（2020-7-22）" class="headerlink" title="单调队列（2020.7.22）"></a>单调队列（2020.7.22）</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1440" target="_blank" rel="noopener"><strong>P1440</strong> 求m区间内的最小值</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1886" target="_blank" rel="noopener"><strong>P1886</strong> 滑动窗口 /【模板】单调队列</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3088" target="_blank" rel="noopener"><strong>P3088</strong>  [USACO13NOV]Crowded Cows S</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1725" target="_blank" rel="noopener"><strong>P1725</strong> 琪露诺</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/U88745" target="_blank" rel="noopener"><strong>U88745</strong> 最大子序和</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/U88746" target="_blank" rel="noopener"><strong>U88746</strong> 烽火传递</a></p>
<p>这六题是第一天所讲的单调队列题目，其中有版子题，也有根据单调队列优化 dp 的内容。我还不大会优化 dp，先放出模板题的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val,pos;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e[i].val);</span><br><span class="line">		e[i].pos=i<span class="number">-1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">//保证是个队列 且保证单调性 </span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()&amp;&amp;q.back().val&gt;e[i].val)</span><br><span class="line">			q.pop_back();</span><br><span class="line">		<span class="comment">//新元素入队 </span></span><br><span class="line">		q.push_back(e[i]);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()&amp;&amp;q.front().pos&lt;i-m)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        ans[i]=q.front().val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字符串问题（2020-7-23）"><a href="#字符串问题（2020-7-23）" class="headerlink" title="字符串问题（2020.7.23）"></a>字符串问题（2020.7.23）</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3375" target="_blank" rel="noopener"><strong>P3375</strong> 【模板】KMP字符串匹配</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2375" target="_blank" rel="noopener"><strong>P2375</strong> [NOI2014]动物园</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2580" target="_blank" rel="noopener"><strong>P2580</strong> 于是他错误的点名开始了</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2292" target="_blank" rel="noopener"><strong>P2292</strong> [HNOI2004]L语言</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3808" target="_blank" rel="noopener"><strong>P3808</strong> 【模板】AC自动机（简单版）</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/U88779" target="_blank" rel="noopener"><strong>U88779</strong> keywords search</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3796" target="_blank" rel="noopener"><strong>P3796</strong> 【模板】AC自动机（加强版）</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2414" target="_blank" rel="noopener"><strong>P2414</strong> [NOI2011]阿狸的打字机</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/CF1200E" target="_blank" rel="noopener"><strong>CF1200E</strong> Compress Words</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P4824" target="_blank" rel="noopener"><strong>P4824</strong> [USACO15FEB]Censoring S</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3435" target="_blank" rel="noopener"><strong>P3435</strong> [POI2006]OKR-Periods of Words</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3121" target="_blank" rel="noopener"><strong>P3121</strong> [USACO15FEB]Censoring G</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3966" target="_blank" rel="noopener"><strong>P3966</strong> [TJOI2013]单词</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3041" target="_blank" rel="noopener"><strong>P3041</strong> [USACO12JAN]Video Game G</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3311" target="_blank" rel="noopener"><strong>P3311</strong> [SDOI2014] 数数</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P4052" target="_blank" rel="noopener"><strong>P4052</strong> [JSOI2007]文本生成器</a></p>
<p>大都不会做，可以说是找到软肋了。</p>
</li>
</ul>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3374" target="_blank" rel="noopener"><strong>P3374</strong> 【模板】树状数组 1</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P2068" target="_blank" rel="noopener"><strong>P2068</strong> 统计和</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/U88769" target="_blank" rel="noopener"><strong>U88769</strong> 数列操作</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3368" target="_blank" rel="noopener"><strong>P3368</strong> 【模板】树状数组 2</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1966" target="_blank" rel="noopener"><strong>P1966</strong> 火柴排队</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1637" target="_blank" rel="noopener"><strong>P1637</strong> 三元上升子序列</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1774" target="_blank" rel="noopener"><strong>P1774</strong> 最接近神的人</a></p>
<p>除了三元上升子序列全部都做完了，三元上升子序列只打了暴力。</p>
<p>给出树状数组知道的使用方法</p>
<p>单点查询 区间查询 单点修改 区间修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x))</span><br><span class="line">        t[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单点加上 k</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=x&amp;-x)</span><br><span class="line">        ans+=t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单点查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于区间修改，我们可以使用差分来完成</span></span><br><span class="line"><span class="comment">//add(x,a[i]-a[i-1])</span></span><br><span class="line"><span class="comment">//此时将 l~r 全部加上 k 只需</span></span><br><span class="line"><span class="comment">//add(x,k) add(y-1,-k)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于区间查询，我们可以使用前缀和来完成</span></span><br><span class="line"><span class="comment">//ask(r)-ask(l-1)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Nauuo-的模拟赛（2020-7-24）"><a href="#Nauuo-的模拟赛（2020-7-24）" class="headerlink" title="Nauuo 的模拟赛（2020.7.24）"></a>Nauuo 的模拟赛（2020.7.24）</h3><p> <a href="https://www.luogu.com.cn/problemnew/show/P4964" target="_blank" rel="noopener"><strong>P4964</strong> 绫小路的特别考试</a></p>
<p>​    这就是要补的题了</p>
<h3 id="manacher（2020-7-27）"><a href="#manacher（2020-7-27）" class="headerlink" title="manacher（2020.7.27）"></a>manacher（2020.7.27）</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P3805" target="_blank" rel="noopener"><strong>P3805</strong> 【模板】manacher算法</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P1659" target="_blank" rel="noopener"><strong>P1659</strong> [国家集训队]拉拉队排练</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problemnew/show/P4555" target="_blank" rel="noopener"><strong>P4555</strong> [国家集训队]最长双回文串</a></p>
<p>最长双回文子串要补。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>2月flag汇总</title>
    <url>/2020/05/01/2%E6%9C%88flag%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p><del>精彩打脸合集</del></p>
</blockquote>
<a id="more"></a>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P3133" target="_blank" rel="noopener">P3133 [USACO16JAN]Radio Contact G</a></p>
<p>一道DP，不会推式子，以后要复习</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[i][j] 表示 FJ 第 i 步，BS 第 j 步时的最小花费</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以从以下三种情况转移过来</span></span><br><span class="line"><span class="comment">1. FJ 不动 BS 动</span></span><br><span class="line"><span class="comment">2. FJ 动 BS 不动</span></span><br><span class="line"><span class="comment">3. FJ 不动 BS 不动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+dis(i,j);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;fj[<span class="number">1005</span>],bs[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fj[i].x-bs[j].x)*(fj[i].x-bs[j].x)+(fj[i].y-bs[j].y)*(fj[i].y-bs[j].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;fj[<span class="number">0</span>].x,&amp;fj[<span class="number">0</span>].y,&amp;bs[<span class="number">0</span>].x,&amp;bs[<span class="number">0</span>].y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'N'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y+<span class="number">1</span>,fj[i].x=fj[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'S'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y<span class="number">-1</span>,fj[i].x=fj[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'W'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y,fj[i].x=fj[i<span class="number">-1</span>].x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'E'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y,fj[i].x=fj[i<span class="number">-1</span>].x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'N'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y+<span class="number">1</span>,bs[i].x=bs[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'S'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y<span class="number">-1</span>,bs[i].x=bs[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'W'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y,bs[i].x=bs[i<span class="number">-1</span>].x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'E'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y,bs[i].x=bs[i<span class="number">-1</span>].x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=f[i<span class="number">-1</span>][<span class="number">0</span>]+dis(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[<span class="number">0</span>][i]=f[<span class="number">0</span>][i<span class="number">-1</span>]+dis(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            f[i][j]=min(f[i<span class="number">-1</span>][j],min(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>]))+dis(i,j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p>
<p>复习了dijkstra，还是不熟，多次WA</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>,M = N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N],book[N],first[N],nxt[M],v[M],w[M],idx,n,m,s,x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    w[idx]=z;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">1e10</span>;</span><br><span class="line">    priority_queue&lt;PII&gt; q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(mp(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.top().se;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(book[t]) <span class="keyword">continue</span>;</span><br><span class="line">        book[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[t];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[t]+w[i]&lt;dis[v[i]]) &#123;</span><br><span class="line">                dis[v[i]]=dis[t]+w[i];</span><br><span class="line">                q.push(mp(-dis[v[i]],v[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//17行挺好打的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)  &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dij();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2015" target="_blank" rel="noopener">P2015 二叉苹果树</a></p>
<p>AC了但确实不会，要复习</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[u][j] 表示以 u 为子树根节点保留 j 条边时的最大苹果数</span></span><br><span class="line"><span class="comment">son[u][0] 表示 u 的左儿子，son[u][1] 表示 u 的右儿子</span></span><br><span class="line"><span class="comment">apple[u][0] 表示 u与 u 的左儿子连边的苹果数，apple[u][1] 表示 u与 u 的右儿子连边的苹果数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用 k 表示保留给以 u 为根节点的子树中分配给 u 的左节点能够保留的边</span></span><br><span class="line"><span class="comment">1. k==0，干掉左子树，探寻右子树的情况</span></span><br><span class="line"><span class="comment">2. k==j，干掉右子树，探寻左子树的情况</span></span><br><span class="line"><span class="comment">3. k&gt;0&amp;&amp;k&lt;j，给左子树 k 条边，右子树 j-k 条边</span></span><br><span class="line"><span class="comment">（实际上如果要保留一棵子树就必定与根节点连有边，所以边的数量-1）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. f[u][j]=max(f[u][j],f[son[u][1]][j-1]+apple[u][1]);</span></span><br><span class="line"><span class="comment">2. f[u][j]=max(f[u][j],f[son[u][0]][j-1]+apple[u][0]);</span></span><br><span class="line"><span class="comment">3. f[u][j]=max(f[u][j],f[son[u][0]][k-1]+apple[u][0]+f[son[u][1]][j-k-1]+apple[u][1]);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">    1. 边权转点权</span></span><br><span class="line"><span class="comment">    2. 树形DP</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,idx;</span><br><span class="line"><span class="keyword">int</span> first[N],nxt[M],v[M],w[M];</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],apple[N][<span class="number">2</span>],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    w[idx]=z;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]!=father) &#123;</span><br><span class="line">            son[u][idx2]=v[i];<span class="comment">//找儿子</span></span><br><span class="line">            apple[u][idx2]=w[i];<span class="comment">//苹果个数</span></span><br><span class="line">            idx2++;</span><br><span class="line">            dfs(v[i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=q;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">                f[u][j]=max(f[u][j],f[son[u][<span class="number">1</span>]][j<span class="number">-1</span>]+apple[u][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//1个都不留的情况，由于本身与根节点有一条边，另一个只能是j-1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k==j)</span><br><span class="line">                f[u][j]=max(f[u][j],f[son[u][<span class="number">0</span>]][j<span class="number">-1</span>]+apple[u][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//all in</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            f[u][j]=max(f[u][j],f[son[u][<span class="number">0</span>]][k<span class="number">-1</span>]+apple[u][<span class="number">0</span>]+f[son[u][<span class="number">1</span>]][j-k<span class="number">-1</span>]+apple[u][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">        add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">1</span>][q]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 636 (Div. 3)</title>
    <url>/2020/04/26/cf1343/</url>
    <content><![CDATA[<blockquote>
<p>日常三题选手…</p>
<p><img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/emojis/majsoul/maj-38.png" alt=""></p>
</blockquote>
<a id="more"></a>
<h2 id="A-Candies"><a href="#A-Candies" class="headerlink" title="A. Candies"></a><a href="https://codeforces.com/contest/1343/problem/A" target="_blank" rel="noopener">A. Candies</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数 $n$，$k$ 为大于 $1$ 的任意整数，求解方程 $x + 2x + 4x + \dots + 2^{k-1} x = n$。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>可以计算得出实质上在求 $(2^{k}-1)x=n$，枚举一下 $2^k-1$，对于 $n \mid 2^k-1$，输出 $x=\dfrac{n}{2^k-1}$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">ll idx[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    idx[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">63</span>;i++) idx[i]=<span class="built_in">pow</span>(<span class="number">2</span>,i)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">63</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%idx[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/idx[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Balanced-Array"><a href="#B-Balanced-Array" class="headerlink" title="B. Balanced Array"></a><a href="https://codeforces.com/contest/1343/problem/B" target="_blank" rel="noopener">B. Balanced Array</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个正整数 $n(n \mid 2)$，构造一个长度为 $n$ 的数组 $a$ 使得 $a$ 的前半部分之和与后半部分之和相等，同时 $a$ 的前半部分都是偶数，后半部分都是奇数，$a$ 中每一个数都不相等。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>首先思考最小的部分（常用套路），发现 $n=2$ 一定无解，$n=4$ 一定有解。观察样例提示可以发现对于任意 $n \mid 4$ 都是有解的，其他则一定无解。构造方式也比较套路，对于 $1 \sim \dfrac{n}{2}$,$a<em>i = 2^i$,对于 $\dfrac{n}{2}+1 \sim n$ , $a_i=a</em> { i - \frac{n}{2} } - 1$ ,再对最后一个数处理一下  $a_n \gets a_n+\dfrac{n}{2}$，就成功的构造出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,a[<span class="number">200005</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>!=<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>) &#123;</span><br><span class="line">                a[++idx]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span><span class="number">-1</span>;i++) &#123;</span><br><span class="line">                idx++;</span><br><span class="line">                a[idx]=a[idx-n/<span class="number">2</span>]<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">            a[idx]=a[idx-n/<span class="number">2</span>]+n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Alternating-Subsequence"><a href="#C-Alternating-Subsequence" class="headerlink" title="C. Alternating Subsequence"></a><a href="https://codeforces.com/contest/1343/problem/C" target="_blank" rel="noopener">C. Alternating Subsequence</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定长度为 $n$ 的序列 $a$，要求求出最长的一正一负的 $a$ 的子序列中的最大和。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>题目要求了最长，可以直接每一段连续区间中只取一个最大的，保证最终和最大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1343/problem/C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> _,n,a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,maxx,minx;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=n+<span class="number">1</span>) &#123;</span><br><span class="line">            maxx=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            minx=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;<span class="number">0</span>&amp;&amp;i!=n+<span class="number">1</span>) &#123;</span><br><span class="line">                maxx=max(maxx,a[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;<span class="number">0</span>) sum+=maxx;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&lt;<span class="number">0</span>&amp;&amp;i!=n+<span class="number">1</span>) &#123;</span><br><span class="line">                minx=max(minx,a[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]&lt;<span class="number">0</span>) sum+=minx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Constant-Palindrome-Sum"><a href="#D-Constant-Palindrome-Sum" class="headerlink" title="D. Constant Palindrome Sum"></a><a href="https://codeforces.com/contest/1343/problem/D" target="_blank" rel="noopener">D. Constant Palindrome Sum</a></h2><p>题目太神仙了，赛后看题解搞出来了，一时半会也不知道怎么做。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 635 (Div. 2)</title>
    <url>/2020/04/24/cf1337/</url>
    <content><![CDATA[<blockquote>
<p>中国场！莫名的激动。题目的风格真的和出题人有关，<del>虽然我只做了三题</del></p>
</blockquote>
<a id="more"></a>
<h2 id="A-Ichihime-and-Triangle"><a href="#A-Ichihime-and-Triangle" class="headerlink" title="A. Ichihime and Triangle"></a><a href="https://codeforces.ml/contest/1337/problem/A" target="_blank" rel="noopener">A. Ichihime and Triangle</a></h2><h3 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h3><p>给定 $a,b,c,d$ 其中 $a \le b \le c \le d$，试找到 $x,y,z$ 其中 </p>
<ul>
<li>$a \leq x \leq b$</li>
<li>$b \leq y \leq c$</li>
<li>$c \leq z \leq d$</li>
</ul>
<p>使得以 $x,y,z$ 为三角形三边长度构成一个三角形。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>一开始的朴素思路是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.ml/contest/1337/problem/0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+a[<span class="number">2</span>]&lt;=a[<span class="number">3</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">3</span>]-a[<span class="number">2</span>]&lt;=a[<span class="number">2</span>]) <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">3</span>]-a[<span class="number">2</span>]+<span class="number">1</span>,a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">1</span>],a[<span class="number">3</span>]-a[<span class="number">1</span>]+<span class="number">1</span>,a[<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 $x,y,z \le 5\times 10^8$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.ml/contest/1337/problem/0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">2</span>],a[<span class="number">3</span>],a[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造一组腰长大于边长的等腰三角形就好了。</p>
<h2 id="B-Kana-and-Dragon-Quest-game"><a href="#B-Kana-and-Dragon-Quest-game" class="headerlink" title="B. Kana and Dragon Quest game"></a><a href="https://codeforces.ml/contest/1337/problem/B" target="_blank" rel="noopener">B. Kana and Dragon Quest game</a></h2><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>一个怪物有 $x$ 的血量，你可以执行最多 $n$ 次操作使得其血量等于 $\left\lfloor \frac{x}{2} \right\rfloor + 10$，也可以执行最多 $m$ 次操作使得其血量等于 $x-10$，问能否杀死它。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>想尽办法用第一种方法就行了，再判断剩下的血量能否被击杀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.ml/contest/1337/problem/B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,m;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%d%d"</span>,&amp;x,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> ansn=<span class="number">0</span>,ansm=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=m*<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ansn&lt;n) &#123;</span><br><span class="line">            x=<span class="built_in">floor</span>(x/<span class="number">2</span>)+<span class="number">10</span>;</span><br><span class="line">            ansn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=m*<span class="number">10</span>) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Linova-and-Kingdom"><a href="#C-Linova-and-Kingdom" class="headerlink" title="C. Linova and Kingdom"></a><a href="https://codeforces.ml/contest/1337/problem/C" target="_blank" rel="noopener">C. Linova and Kingdom</a></h2><h3 id="题意简述-1"><a href="#题意简述-1" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定一棵 $n$ 个节点的树，选择 $k$ 个节点，使得从这些节点出发到根节点经过的非选中的点数量尽可能多，求出最大值。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>显而易见的选择 $k$ 个深度最深的点就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2</span>*<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> idx,v[maxn*<span class="number">2</span>],first[maxn],nxt[maxn*<span class="number">2</span>],x,y,n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sz,dep;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a1,node a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a1.dep-a1.sz&gt;a2.dep-a2.sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	a[u].sz=<span class="number">1</span>,a[u].dep=a[fa].dep+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=first[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(v[i]!=fa)</span><br><span class="line">            dfs(v[i],u),a[u].sz+=a[v[i]].sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    a[<span class="number">0</span>].dep=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) ans+=a[i].dep-a[i].sz;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Xenia-and-Colorful-Gems"><a href="#D-Xenia-and-Colorful-Gems" class="headerlink" title="D. Xenia and Colorful Gems"></a><a href="https://codeforces.ml/contest/1337/problem/D" target="_blank" rel="noopener">D. Xenia and Colorful Gems</a></h2><p>题目太神仙了，先gugugu</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 633 (Div. 2)</title>
    <url>/2020/04/24/cf1339/</url>
    <content><![CDATA[<blockquote>
<p>可能是到目前为止最成功的一次 cf 了，下次要做到没人带我也这么强。</p>
</blockquote>
<a id="more"></a>
<h2 id="A-Filling-Diamonds"><a href="#A-Filling-Diamonds" class="headerlink" title="A. Filling Diamonds"></a><a href="https://codeforces.com/contest/1339/problem/A" target="_blank" rel="noopener">A. Filling Diamonds</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定形如下图的形状，问用形如 $n=1$ 时的图形完全填充的方案数。</p>
<p><img src="https://www.superbed.cn/item/5ea265a9c2a9a83be51bb2bf.png" alt=""></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>模拟发现每种方案有且仅有一个竖着摆放的形状，答案即为 $n$ 。</p>
<p><img src="https://www.superbed.cn/item/5ea265aac2a9a83be51bb428.png" alt=""></p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Sorted-Adjacent-Differences"><a href="#B-Sorted-Adjacent-Differences" class="headerlink" title="B. Sorted Adjacent Differences"></a><a href="https://codeforces.com/contest/1339/problem/B" target="_blank" rel="noopener">B. Sorted Adjacent Differences</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组 $a$  要求重排使得 $|a<em>1 - a_2| \le |a_2 - a_3| \le \ldots \le |a</em>{n-1} - a_n|$。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>最大的和最小的放一起，产生的差当然是最大的，直接放到最后，接着是次大值和次小值。</p>
<p><img src="https://pic.downk.cc/item/5ea2b795c2a9a83be58337f6.gif" alt=""></p>
<p>推一下就知道每个元素最后的位置是什么了，可以按照官方题解所说的确定中间位置之后一左一右就可以了。</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> m=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[m]);</span><br><span class="line">            m+=i&amp;<span class="number">1</span>?i:-i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Powered-Addition"><a href="#C-Powered-Addition" class="headerlink" title="C. Powered Addition"></a><a href="https://codeforces.com/contest/1339/problem/C" target="_blank" rel="noopener">C. Powered Addition</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组 $a$，可以在第 $x$ 秒给 $a$ 中任意一段连续的数加上 $2^{x-1}$（或者不加），问至少多少秒后使得数组不递减。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>每次加 $a_i$ 的时候将连续的一段 $a_j \leq a_i (j&gt;i)$ 全部也加上，判断是否不递减</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line">ll _,n,a[maxn],maxa,ans,j,k,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        k=<span class="number">1</span>,sum=ans=<span class="number">0</span>,maxa=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">while</span>(a[i]+sum&lt;maxa) &#123;<span class="comment">//加上 sum 还是不行，只能加更多</span></span><br><span class="line">                sum+=k,ans++;</span><br><span class="line">                <span class="keyword">if</span>(k&lt;=<span class="number">1e10</span><span class="number">-1</span>) k=k&lt;&lt;<span class="number">1</span>;<span class="comment">//k = 2^&#123;x-1&#125;</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxa=maxa&gt;a[i]?maxa:a[i];<span class="comment">//更新当前一段已知最大值，之后的必须大于等于 maxa</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Edge-Weight-Assignment"><a href="#D-Edge-Weight-Assignment" class="headerlink" title="D. Edge Weight Assignment"></a><a href="https://codeforces.com/contest/1339/problem/D" target="_blank" rel="noopener">D. Edge Weight Assignment</a></h2><p>太神仙了，先gugugu</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次比较明显的感受就是想法全是对的，这是思维得到训练的结果，但是实现起来非常复杂，还搞错了好几次，其实就是练少了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP的一些理解</title>
    <url>/2020/04/17/%E5%8C%BA%E9%97%B4DP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>区间$\text{DP}$比线性$\text{DP}$好想一些。</p>
</blockquote>
<a id="more"></a>
<h2 id="合并沙子"><a href="#合并沙子" class="headerlink" title="合并沙子"></a><a href="https://www.acoj.com/problems/12449" target="_blank" rel="noopener">合并沙子</a></h2><p>对于一道典型的区间$\text{DP}$问题，我们很容易思考到如何划分区间（集合）？</p>
<p>显然，最小的区间是每个数本身，此时合并花费一定最少（因为不需要花费）</p>
<p>考虑两个数作为一个区间，此时无论怎么合并花费一定最少（只有一种合并方法）</p>
<p>对于三个数及以上显然不存在直接合并一定最少的情况，例如 $1,3,100$ 如果先合并 $3,100$ 再合并 $1,103$ 总花费是 $207$ ，先合并 $1,3$ 再合并 $4,100$ 总花费则为 $108$。</p>
<p>那我们可以一直划分一个长度大于等于三的区间，那么显然前一部分的最小加上后一部分的最小使得总体最小，满足最优子结构</p>
<script type="math/tex; mode=display">
f(i,j)=\min\{f(i,k)+f(k+1,r)+cost(i,j)\} \\
      \ \ \ \ \ \ \ \ \ \ =\min\{f(i,k)+f(k+1,r)\}+cost(i,j)</script><p>其中 $f(i,j)$ 表示合并 $i\sim j$ 的最小花费 $cost(i,j)$ 为合并 $i,j$ 的最小代价</p>
<p><img src="https://pic.downk.cc/item/5e995fd1c2a9a83be56f8f3f.png" alt=""></p>
<p>想知道 $cost(i,j)$ 可以采用前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+sum(l,r)(l&lt;=k&lt;=r)</span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">305</span>],b[<span class="number">305</span>],f[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i],f[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len&lt;=n;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=len+l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;r;k++)</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举每一个长度 $\text{len}$ 的序列的最小合并花费，最终求出 $f(1,n)$ 即最终的最小花费。</p>
<h2 id="环形合并石子"><a href="#环形合并石子" class="headerlink" title="环形合并石子"></a><a href="https://www.acoj.com/problems/12690" target="_blank" rel="noopener">环形合并石子</a></h2><p>有了上一题的经验，很容易知道这一题的结论也是 $f(i,j) = \min \{ f(i,k) + f(k+1,r) \} + sum(i,j)$  </p>
<p>难点在于<strong>环形</strong>，我们可以用一个简单的办法解决，原序列展开最多 $n$ 的长度，我们只需要把整个序列复制一遍使其能够计算到 $2n$ 的位置就可以了</p>
<p><code>a[i+n]=a[i];</code> </p>
<p>对于最大值和最小值可以开两个数组 f, g 来解决，本质是一样的，但是要枚举每次长度为 $n$ 的序列的起始点才能找到最大值和最小值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//f[i][j]=min(f[l][r],f[i][k]+f[k+1][r])+sum(l,r)(l&lt;=k&lt;=r)</span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">605</span>],b[<span class="number">605</span>],f[<span class="number">605</span>][<span class="number">605</span>],g[<span class="number">605</span>][<span class="number">605</span>],res1=<span class="number">0x7fffff</span>,res2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) b[i]=b[i<span class="number">-1</span>]+a[i],f[i][i]=g[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len&lt;=n*<span class="number">2</span>;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">            	g[l][r]=max(g[l][r],g[l][k]+g[k+<span class="number">1</span>][r]+b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res1=min(res1,f[i][i+n<span class="number">-1</span>]),res2=max(res2,g[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,res1,res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加分二叉树"><a href="#加分二叉树" class="headerlink" title="加分二叉树"></a><a href="https://www.acoj.com/problems/12454" target="_blank" rel="noopener">加分二叉树</a></h2><p>为什么树也是区间$\text{DP}$？</p>
<p>这里运用了中序遍历的性质（拍扁序）直接成为了一个区间</p>
<p>每次如果能够更新则根的序号改变。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//f[i][j]=max(f[i][k-1]*f[k+1][j]+a[k])(l&lt;=k&lt;=r)</span></span><br><span class="line"><span class="comment">//k==l||k==r 特殊处理</span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">35</span>],f[<span class="number">35</span>][<span class="number">35</span>],g[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,g[l][r]);</span><br><span class="line">    dfs(l,g[l][r]<span class="number">-1</span>);</span><br><span class="line">    dfs(g[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        f[i][i]=a[i];</span><br><span class="line">        <span class="comment">//叶子节点就直接是自己</span></span><br><span class="line">        g[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len&lt;=n;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=r;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==l) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[l][r]&lt;a[l]+f[k+<span class="number">1</span>][r])</span><br><span class="line">                        f[l][r]=a[l]+f[k+<span class="number">1</span>][r],g[l][r]=k;</span><br><span class="line">                    <span class="comment">//f[l][r]=max(f[l][r],a[l]+f[k+1][r]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(k==r) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[l][r]&lt;a[r]+f[l][k<span class="number">-1</span>])</span><br><span class="line">                        f[l][r]=a[r]+f[l][k<span class="number">-1</span>],g[l][r]=k;</span><br><span class="line">                    <span class="comment">//f[l][r]=max(f[l][r],a[r]+f[l][k-1]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[l][r]&lt;a[k]+f[l][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][r])</span><br><span class="line">                        f[l][r]=a[k]+f[l][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][r],g[l][r]=k;</span><br><span class="line">                    <span class="comment">//f[l][r]=max(f[l][r],a[k]+f[l][k-1]*f[k+1][r]);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    dfs(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>限于作者本人能力有限，期待各位多提些建议</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法的一些个人理解</title>
    <url>/2020/04/12/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>update on 2020.4.26 新增<a href="https://www.luogu.com.cn/problem/P3275" target="_blank" rel="noopener">糖果</a>代码</p>
<h2 id="浅谈差分约束"><a href="#浅谈差分约束" class="headerlink" title="浅谈差分约束"></a>浅谈差分约束</h2><p><strong>差分约束系统</strong> 是一种特殊的 $n$ 元一次不等式组，它包含 $n$ 个变量 $x_1,x_2,\cdots x_n$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j \leq c_k$，其中 $c_k$ 是常数（可以是非负数，也可以是负数）。我们要解决的问题是：求一组解 ，使得所有的约束条件得到满足，否则判断出无解。</p>
<a id="more"></a>
<p>差分约束系统中的每个约束条件 $x_i-x_j\leq c_k$ 都可以变形成 $x_i \leq x_j+c_k$，这与单源最短路中的三角形不等式 $dist[y] \leq dist[x]+z$ 非常相似。因此，我们可以把每个变量 $x_i$ 看做图中的一个结点，对于每个约束条件 $x_i-x_j\leq c_k$，从结点 $j$ 向结点 $i$ 连一条长度为 $c_k$ 的有向边。</p>
<p>注意到，如果 ${a_1,a_2,\cdots ,a_n}$ 是该差分约束系统的一组解，那么对于任意的常数 $d$，${a_1+d,a_2+d,\cdots ,a_n}$ 显然也是该差分约束系统的一组解，因为这样做差后 $d$ 刚好被消掉。</p>
<p>设 $dist[0]=0$ 并向每一个点连一条边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则，$x_i=dist[i]$ 为该差分约束系统的一组解。</p>
<p>一般使用 Bellman-Ford 或队列优化的 Bellman-Ford（俗称 SPFA，在某些随机图跑得很快）判断图中是否存在负环，最坏时间复杂度为 $O(nm)$。</p>
<blockquote>
<p>个人理解：</p>
<ol>
<li><p>差分约束系统是一种特殊的 $n$ 元一次不等式组</p>
</li>
<li><p>约束条件形如 $x_i-x_j \leq c_k$</p>
</li>
<li><p>一些对照</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">差分约束中的条件</th>
<th style="text-align:center">三角形不等式中的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x_i$​</td>
<td style="text-align:center">$dist[y]$</td>
</tr>
<tr>
<td style="text-align:center">$x_j$​</td>
<td style="text-align:center">$dist[x]$</td>
</tr>
<tr>
<td style="text-align:center">$c_k$​</td>
<td style="text-align:center">$z$​</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>$dist[0]$ 其实就是建立了超级源点</p>
</li>
<li><script type="math/tex; mode=display">
\left\{
\begin{aligned}
x_1 \leq x_3+3 \\
x_2 \leq x_1-5 \\
x_3 \leq x_2-3
\end{aligned}
\right.</script><p>以此为例建图</p>
<p><img src="https://pic.downk.cc/item/5e91f3c8504f4bcb0407f4ae.png" alt=""></p>
<p>显然 1→2→3→1 形成了一个负环，显然是不可解的（此时无最短路）</p>
</li>
<li><p>为什么？我的理解是如果建出的图存在有负环，那么原差分约束系统中的约束条件必然相互矛盾，上例中是 $x_1 \leq x_1-5$</p>
</li>
<li><p>实际上这是一种抽象的概念，将某一类复杂的问题巧妙的结合在图论模型中再用最短路求解，实际上，图论问题，建图最难</p>
</li>
</ol>
</blockquote>
<p>SPFA虽然已经成为了被卡掉的算法（包括各个优化），其实用性仍然是很好的。</p>
<p>如果以 $x_1,x_2$ 表示两个变量，$x_1-x_2 \leq c$ 有如下条件是等价的</p>
<script type="math/tex; mode=display">
x_1-x_2 \leq c \Leftrightarrow  x_1-x_2 \geq -c \Leftrightarrow x_1-x_2 < c+1 \Leftrightarrow x_1-x_2 > -c-1</script><p> 如果 $x_1-x_2=c$，有 $x_1-x_2 \geq c,x_1-x_2 \leq c$</p>
<p>（其实上面的做法是为了解决糖果这道题）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>,M = N*<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> n,m,op,x,y,idx,v[M],w[M],dis[N],book[N],cnt[N],first[N],nxt[M];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    w[idx]=z;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    book[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        book[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[t]++==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[t];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p=v[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[p]&lt;dis[t]+w[i]) &#123;</span><br><span class="line">                dis[p]=dis[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!book[p]) &#123;</span><br><span class="line">                    book[p]=<span class="number">1</span>;</span><br><span class="line">                    q.push(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add(x,y,<span class="number">0</span>);add(y,x,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                add(x,y,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                add(y,x,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                add(y,x,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                add(x,y,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;x==y) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>),<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) add(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!spfa())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        ans+=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 629 (Div. 3)</title>
    <url>/2020/03/27/cf1328/</url>
    <content><![CDATA[<h2 id="A-Divisibility-Problem"><a href="#A-Divisibility-Problem" class="headerlink" title="A Divisibility Problem"></a><a href="https://www.luogu.com.cn/problem/CF1328A" target="_blank" rel="noopener">A Divisibility Problem</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个正整数 $a$ 和 $b$，你可以在一步操作中将 $a$ 加上 $1$。你需要找到最少需要多少步操作可以使得 $a \mid b $。存在最开始就满足 $a \mid b$ 的可能从而只需要 $0$ 步操作。</p>
<a id="more"></a>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $t( 1 \le t \le 10^4)$。</p>
<p>之后 $t$ 行每行两个正整数 $a,b(1\le a,b \le 10^9)$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 $t$ 行，每行一个整数，表示能达到 $a\mid b$ 的最小操作步数。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>题面上描述的是 $a \mid b$ 也就是 $a$ 能够整除 $b$ ，对于 $a \nmid b$ 一定是形如 $a \div b=c\cdots d$ ，那么相当于去枚举一个 $c$ 。我们可以知道 $b\times( c+1)$ 就是第一个能整除 $b$ 的整数，一开始是 $c\times b$ 现在是 $(c+1)\times b$ ，所以多了一个 $b$ ，之前比 $c\times b$ 多了 $d$ 最终所需要的答案也就是 $b-d$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="keyword">if</span>(a % b == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b - a % b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-K-th-Beautiful-String"><a href="#B-K-th-Beautiful-String" class="headerlink" title="B K-th Beautiful String"></a><a href="https://www.luogu.com.cn/problem/CF1328B" target="_blank" rel="noopener">B K-th Beautiful String</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个正整数 $n,k$，生成 $\frac{n \cdot (n-1)}{2}$ 组长度为 $n$ 其中 $n-2$ 个 <code>a</code> ，$2$ 个 <code>b</code> 的字符串，求按字典序排序后第 $k$ 个字符串。</p>
<p>对于两个长度相等的字符串 $s,t$ 如果存在 $i(1\le i \le n)$ 使得 $s_i&lt;t_i$ 且存在 $j( 1 \le j &lt; i )$ 使得 $s_j = t_j$，$s$ 的字典序小于 $t$。</p>
<p>这是 $n=5$ 时的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaabb</span><br><span class="line">aabab</span><br><span class="line">aabba</span><br><span class="line">abaab</span><br><span class="line">ababa</span><br><span class="line">abbaa</span><br><span class="line">baaab</span><br><span class="line">baaba</span><br><span class="line">babaa</span><br><span class="line">bbaaa</span><br></pre></td></tr></table></figure>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $t( 1 \le t \le 10^4)$。</p>
<p>之后 $t$ 行每行两个正整数 $n,k(3\le n \le 10^5,1 \le k \le \min(2 \cdot 10^9,\frac{n \cdot (n-1)}{2}))$。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 $t$ 行，每行一个字符串，表示按字典序排序后第 $k$ 个字符串。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>我们用 $x$ 来表示第一个 <code>b</code> 出现的位置，用 $y$ 来表示第二个 <code>b</code> 出现的位置，一开始 $x=n-1,y=n$，我们发现有如下规则</p>
<ol>
<li>$x=y-1$，$x\gets x-1,y=n$</li>
<li>$x \ne y-1$，$y\gets y-1$</li>
</ol>
<p>如果只考虑 $x$ ，当 $y = n$ 的时候，要移动到 $x$，需要 $n-x+1$ 步。</p>
<p>而 $x$ 的分布规律和 $k_i$ 的分布也是有关系的，拿题目中的样例解释</p>
<ol>
<li><code>aaabb</code> $x=4,y=5,k=1$</li>
<li><code>aabab</code> $x=3,y=5,k=2$</li>
<li><code>aabba</code> $x=3,y=4,k=3$</li>
<li><code>abaab</code> $x=2,y=5,k=4$</li>
<li><code>ababa</code> $x=2,y=4,k=5$</li>
<li><code>abbaa</code> $x=2,y=3,k=6$</li>
<li><code>baaab</code> $x=1,y=5,k=7$</li>
<li><code>baaba</code> $x=1,y=4,k=8$</li>
<li><code>babaa</code> $x=1,y=3,k=9$</li>
<li><code>bbaaa</code> $x=1,y=2,k=10$</li>
</ol>
<p>我们提取出每次使得 $x$ 的值同上一个 $x$ 的值不同的 $k$ 也就是 ${1,2,4,7,\cdots}$</p>
<p>这些数有什么规律呢？很容易发现这个数列的规律是 $+1,+2,+3,+\cdots$</p>
<p>我们可以处理出这样的一个数列 $ka={1,2,4,7,\cdots}$，那么对于 <script type="math/tex">[ka_i,ka_{i+1})</script> 这么一个区间中的每一个 <script type="math/tex">x</script> 都满足 <script type="math/tex">x=n-i,y=n-k+ka_i</script> ，这一题的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> t,a,b,p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">100000</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getcha();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	k[<span class="number">1</span>]=<span class="number">1</span>,k[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">100005</span>;++i) k[i]=k[i<span class="number">-1</span>]+i<span class="number">-1</span>;</span><br><span class="line">	t=read();</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		a=read(),b=read();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) ch[i]=<span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) <span class="keyword">if</span>(k[i+<span class="number">1</span>]&gt;b) &#123;p=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="comment">//也可以用p=lower_bound(k+1,k+1+a,b+1)-k-1;</span></span><br><span class="line">		ch[a-p]=ch[a-b+k[p]]=<span class="string">'b'</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,ch[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Ternary-XOR"><a href="#C-Ternary-XOR" class="headerlink" title="C Ternary XOR"></a><a href="https://www.luogu.com.cn/problem/CF1328C" target="_blank" rel="noopener">C Ternary XOR</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个三进制数各位必定由 $0,1,2$ 组成，例如 $1022,11,21,2022$。</p>
<p>给定一个三进制数 $x$,$x$ 的首位必定为 $2$，其余位数有可能是 $0$ 或 $1$ 或 $2$ 。</p>
<p>我们定义三进制的异或操作符 $⊙$，对于两个长度均为 $n$ 的三进制数 $a,b$ ，$a⊙b$ 的结果为 $c$，$c_i=(a_i+b_i) \bmod 3 $。这也就是说，将 $a,b$ 相应的数字相加并除以 $3$。例如，$10222⊙11021=21210$。</p>
<p>你需要找到两个长度为 $n$ 且没有前导零的三进制数 $a,b$ 使得 $a⊙b=x$ 且 $\max {a,b }$ 最小。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $t( 1 \le t \le 10^4)$。</p>
<p>之后 $t$ 组数据每组数据第一行一个正整数 $n(1 \le n \le 5 \cdot 10^4)$ 表示 $x$ 的长度为 $n$，第二行一个长度为 $n$ 的三进制数 $x$ （$x$ 由 $n$ 个 $0$ 或 $1$ 或 $2$ 组成且没有前导零）。</p>
<p>保证所有组数据 $n$ 的总和不超过 $5 \cdot 10^4(\sum n \le 5 \cdot 10^4)$。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 $t$ 组，每组两行，两个使得 $a⊙b=x$ 且 $\max {a,b }$ 最小的长度为 $n$ 的三进制数 $a,b$。</p>
<p>如果有多组 $a,b$ 满足条件，输出任意一种。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>如果要使 $\max {a,b }$ 最小，那么一定不存在进位。</p>
<p>对于 $a=b$ </p>
<ol>
<li>$x_i=0$ $a_i=b_i=0$</li>
<li>$x_i=1$ $a_i=1,b_i=0$</li>
<li>$x_i=2$ $a_i=b_i=1$ </li>
</ol>
<p>对于 $a&gt;b$</p>
<ol>
<li>$x_i=0$ $a_i=b_i=0$</li>
<li>$x_i=1$ $a_i=0,b_i=1$</li>
<li>$x_i=2$ $a_i=0,b_i=2$</li>
</ol>
<p>（因为 $a=b$ 时的第二条规则保证存在至少一个 $i$ 使得 $a_i&gt;b_i$ 从而保证了 $a&gt;b$ 所以可以在 $a&gt;b$ 时把所有位上的数给 $b$，避免将 $a$ 的值增大）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,len,flag;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">50015</span>],c1[<span class="number">50015</span>],c2[<span class="number">50015</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t=read();</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        len=read();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c+<span class="number">1</span>);</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span>(c[i]==<span class="string">'2'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">if</span>(!flag) c1[i]=c2[i]=<span class="string">'1'</span>;</span><br><span class="line">				<span class="keyword">else</span> c1[i]=<span class="string">'0'</span>,c2[i]=<span class="string">'2'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">if</span>(!flag) c1[i]=<span class="string">'1'</span>,c2[i]=<span class="string">'0'</span>,flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> c1[i]=<span class="string">'0'</span>,c2[i]=<span class="string">'1'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'0'</span>) c1[i]=c2[i]=<span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,c1[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,c2[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P6236 [COCI2010-2011] LJUTNJA</title>
    <url>/2020/03/25/lg6236/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6236" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>幼儿园的小孩们收到了一个有 $m$ 颗糖果的大包裹，现在要把这些糖果分给 $n$ 个小孩。</p>
<p>每一个小孩都给出了一个期望的糖果数，如果没有达到他的期望值 $a_i$，小孩就会生气。每差一个糖果，小孩的生气指数就会增加，可以认为他生气的程度等于他少得到的糖果数的平方。</p>
<p>比如，Mirko 想要得到 $32$ 个糖果，但是只得到了 $29$ 个。他少了 $3$ 个，所以他的生气指数是 $9$。不幸的是，糖果数不足以满足所有小孩的期望。所以我们应该采取最优的分配方法，使得最后小孩们的生气指数的和最小。</p>
<a id="more"></a>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入数据共 $n+1$ 行。</p>
<p>第一行两个整数 $m,n$。</p>
<p>接下来 $n$ 行，每行一个整数，第 $i+1$ 行的整数表示第 $i$ 个小朋友期望值 $a_i$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出数据共一行。</p>
<p>一行一个整数，表示最小的总生气指数。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>输出1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这一题首先要知道分糖果的策略，我们通过样例进行研究，将  $1$ 个糖果分给任意一个小朋友，怎样才是最优的？如果给 $a_i=5$ 的小朋友那么生气指数减少了 $5^2-4^2=9$，给 $a_i=4$ 的小朋友那么生气指数减少了 $4^2-3^2=7$ 的生气指数，以此类推，给 $i$ 号小朋友实质上生气指数会减少 ${a_i}^2-(a_i-1)^2$ 而给了一个之后 $a_i$ 就会变成 $a_i-1$ 我们只要找到每次给糖果之后生气指数减少最多的（也就是当前离目标差值最大的）就可以做了。</p>
<p>我拿样例来解释一下这个过程</p>
<ol>
<li><p>排序得到 $5,4,3,2$</p>
</li>
<li><p>找到最大值 $maxn$ 为 $5$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</p>
</li>
<li><p>找到最大值 $maxn$ 为 $4$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</p>
</li>
<li>找到最大值 $maxn$ 为 $3$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</li>
<li>找到最大值 $maxn$ 为 $2$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</li>
<li>$m=0$ 结束，计算最终和 $sum$ </li>
</ol>
<p>抽象一下</p>
<ol>
<li>排序</li>
<li>找到最大值，所有最大值减一（满足 $m&gt;0$）不断重复此过程</li>
<li>计算最终和 $sum$ </li>
</ol>
<p>如果还不明白的话就看一下代码吧（注意，unsigned long long 的最大值才是 $2^{64}-1$ ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100005</span>],sum,n,m,maxn,idx=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=read(),n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//从大到小排序</span></span><br><span class="line">    maxn=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[idx]!=maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=a[<span class="number">1</span>],idx=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        a[idx]-=<span class="number">1</span>,m-=<span class="number">1</span>,idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum+=a[i]*a[i];<span class="comment">//计算最终和</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llu"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次CF比赛</title>
    <url>/2020/03/24/%E7%AC%AC%E4%B8%80%E6%AC%A1CF%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<p>CF上的题目确实值得一做，打比赛是提升代码水平的好方法。</p>
<a id="more"></a>
<h2 id="参赛感想"><a href="#参赛感想" class="headerlink" title="参赛感想"></a>参赛感想</h2><p>​    我参加的第一场 CF 比赛是 Educational Codeforces Round 84 (Rated for Div. 2)。我很早就注册了CF账号，但是打比赛还是第一次。原先总觉得CF的题都好难，实际上真正去做的时候发现自己只要有时间还是可以做出来几题的。CF的题目是典型的思维题，没有思维很难想到。最终的码量都不会很大（这让我在最后时刻抢着把 B 题做完了）。（非常感谢 too_late 对我的鼓励）</p>
<h2 id="题解（只有-A-B-C）"><a href="#题解（只有-A-B-C）" class="headerlink" title="题解（只有 A,B,C）"></a>题解（只有 A,B,C）</h2><h3 id="A-Sum-of-Odd-Integers"><a href="#A-Sum-of-Odd-Integers" class="headerlink" title="A Sum of Odd Integers"></a><a href="https://www.luogu.com.cn/problem/CF1327A" target="_blank" rel="noopener">A Sum of Odd Integers</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 $n,k$,求是否能用 $k$ 个不同奇数的和来表示 $n$。</p>
<h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行一个正整数 $t(1\leq t\leq 10^5)$</p>
<p>之后 $t$ 每行两个正整数 $n,k(1\leq n,k \leq 10^7)$</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果有解，输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line">10 3</span><br><span class="line">10 2</span><br><span class="line">16 4</span><br><span class="line">16 5</span><br></pre></td></tr></table></figure>
<p>输出1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>​    这一题一开始先手玩了一下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字 $n$</th>
<th>可以满足的 $k$</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td>$1$</td>
<td>$1=1$</td>
</tr>
<tr>
<td>$2$</td>
<td>无</td>
<td>$1+3=4&gt;2$</td>
</tr>
<tr>
<td>$3$</td>
<td>$1$</td>
<td>$3=3$</td>
</tr>
<tr>
<td>$4$</td>
<td>$2$</td>
<td>$1+3=4$</td>
</tr>
<tr>
<td>$5$</td>
<td>$1$</td>
<td>$5=5$</td>
</tr>
<tr>
<td>$6$</td>
<td>$2$</td>
<td>$1+5=6$</td>
</tr>
<tr>
<td>$7$</td>
<td>$1$</td>
<td>$7=7$</td>
</tr>
<tr>
<td>$8$</td>
<td>$2$</td>
<td>$3+5=8$</td>
</tr>
<tr>
<td>$9$</td>
<td>$1,3$</td>
<td>$9=9$,$1+3+5=9$</td>
</tr>
</tbody>
</table>
</div>
<p>可以发现一个规律，$n,k$ 的奇偶性都是相同的，也许并不那么显然。还有一个规律，所有满足条件的 $k$ 都是小于 $\sqrt n$ 的，这个题目的证明可以参照 <a href="https://www.luogu.com.cn/blog/writeSTL/solution-cf1327a" target="_blank" rel="noopener">jijidawang 的博客</a>。</p>
<p>得出</p>
<blockquote>
<p>$n-k^2\ge 0$ 且 $(n-k^2)\bmod 2=0$ 是有解的<strong>充要条件</strong>。</p>
</blockquote>
<p>代码就呼之欲出了（但是很坑的是计算 $k^2$ 要开 long long）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t,n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=read(),k=read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,n%<span class="number">2</span>==k%<span class="number">2</span>&amp;&amp;n&gt;=k*k?<span class="string">"YES\n"</span>:<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Princesses-and-Princes"><a href="#B-Princesses-and-Princes" class="headerlink" title="B Princesses and Princes"></a><a href="https://www.luogu.com.cn/problem/CF1327B" target="_blank" rel="noopener">B Princesses and Princes</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 $n$ 个公主和王子，每个公主依次选择她喜欢并且没有结婚的王子结婚，问能不能让一个公主再多喜欢一个王子，使得最终配对的对数更多。</p>
<h4 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行一个正整数 $t(1\leq t\leq 10^5)$</p>
<p>之后 $t$ 组数据</p>
<p>每组数据第一行 $1$ 个正整数 $n(1\leq n \leq 10^5)$</p>
<p>接下来 $n$ 行每行第一个正整数 $k(0\leq k\leq n)$ 随后 $k$ 个正整数表示第 $i$ 个公主可以配对的王子编号</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果可以通过加入一个不在公主喜欢名单中的王子到这个公主的喜欢名单中使得配对数更多，输出两行，第一行 <code>IMPROVE</code>，第二行两个对应的公主王子编号，否则输出一行，<code>OPTIMAL</code>。</p>
<h4 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">2 2 3</span><br><span class="line">2 1 2</span><br><span class="line">2 3 4</span><br><span class="line">1 3</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">3 1 2 3</span><br><span class="line">3 1 2 3</span><br><span class="line">3 1 2 3</span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<p>输出1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMPROVE</span><br><span class="line">4 4</span><br><span class="line">IMPROVE</span><br><span class="line">1 1</span><br><span class="line">OPTIMAL</span><br><span class="line">OPTIMAL</span><br><span class="line">OPTIMAL</span><br></pre></td></tr></table></figure>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>非常简单的模拟。（但是要注意不要使用 <code>memset</code> 会超时，直接 <code>for</code> 赋值就好了）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>],b[<span class="number">100005</span>],n,t,m,p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>;</span><br><span class="line">        n=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m=read();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                p=read();</span><br><span class="line">                <span class="keyword">if</span>(b[p]==<span class="number">0</span>&amp;&amp;a[i]==<span class="number">0</span>) a[i]=<span class="number">1</span>,b[p]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">0</span>) flag1=i;</span><br><span class="line">            <span class="keyword">if</span>(b[i]==<span class="number">0</span>) flag2=i;</span><br><span class="line">            <span class="keyword">if</span>(flag1&amp;&amp;flag2) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1&amp;&amp;flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"IMPROVE\n%d %d\n"</span>,flag1,flag2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"OPTIMAL\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Game-with-Chips"><a href="#C-Game-with-Chips" class="headerlink" title="C Game with Chips"></a><a href="https://www.luogu.com.cn/problem/CF1327C" target="_blank" rel="noopener">C Game with Chips</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>Petya 有一个大小为 $n×m$ 的矩形版。一开始，在板子上有 $k$ 个芯片，第 $i$ 个芯片位置位于第 $sx$ 行与第 $sy$ 列的相交点上。</p>
<p>在一次操作中， Petya 可以把所有的芯片向左、向右、向下或者向上移动一格。</p>
<p>如果芯片在 $(x, y)$ 格中，则在操作之后：</p>
<ul>
<li>往左：坐标为 $(x, y - 1)$;</li>
<li>往右：坐标为 $(x, y + 1)$;</li>
<li>往下：坐标为 $(x + 1, y)$;</li>
<li>往上：坐标为 $(x - 1, y)$;</li>
</ul>
<p>如果现在芯片在版的边缘上，然而 Petya 将其移向边缘，那么芯片的位置保持不变。</p>
<p>对于每一个芯片， Petya 选择了它应该到达的位置。注意 芯片不需要在这个地方停下来。</p>
<p>由于 Petya 时间不多， 总操作数不能超过 $2nm$。</p>
<p>你需要求出 Petya 应该做的操作：在不超过 $2nm$ 次的操作里让每个芯片走过 Petya 选定的位置一遍。或者说明是不可能达到目的的。</p>
<h4 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行三个正整数 $n,m,k ( 1 \le n, m, k \le 200)$ </p>
<p>接下来 $k$ 行每行两个正整数 $sx,sy$ 表示每个芯片的初始位置</p>
<p>接下来 $k$ 行每行两个正整数 $fx,fy$ 表示每个芯片应该经过的位置</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>在第一行中输出操作的次数，以便每个芯片至少访问一次 Petya 为其选择的位置。<br>在第二行中输出操作序列。为了表示左、右、下和上的操作，分别使用字符 <code>L</code>,<code>R</code>,<code>D</code>,<code>U</code>。<br>如果所需的序列不存在，请在单行中打印 <code>-1</code>。</p>
<h4 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>
<p>输出1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">DRD</span><br></pre></td></tr></table></figure>
<p>输入2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br><span class="line">5 3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<p>输出2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">DDLUUUURR</span><br></pre></td></tr></table></figure>
<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>​    奇妙思路，将所有芯片通过至多 $m-1$ 次向右的操作和至多 $n-1$ 次向下的操作放到右下角，然后暴力扫一遍，总共的次数 $mn+m+n-3<2nm$ 。但是要特判 $n+m>nm$ 的情况，也很简单。所以说，这一题和 $k,sx,sy,fx,fy$ 无关直接输出方案就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k,idx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read(),k=read();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m*<span class="number">2</span><span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"L"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n*<span class="number">2</span><span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"U"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m*n+m+n<span class="number">-3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">    <span class="keyword">while</span>(idx!=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"%c"</span>,idx%<span class="number">2</span>==<span class="number">0</span>?<span class="string">'U'</span>:<span class="string">'D'</span>);</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span>(idx==m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="D-E-F-G我都不会，也没时间去做了，如果以后做了会放代码的"><a href="#D-E-F-G我都不会，也没时间去做了，如果以后做了会放代码的" class="headerlink" title="D E F G我都不会，也没时间去做了，如果以后做了会放代码的"></a>D E F G我都不会，也没时间去做了，如果以后做了会放代码的</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次 CF 的体验还是很不错的，就是没有那种竞赛的状态，速度也提不上来（再次证明我的题做的太少了），感谢观看。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>奇偶性</tag>
      </tags>
  </entry>
  <entry>
    <title>生动形象的理解二维前缀和</title>
    <url>/2020/03/15/%E7%94%9F%E5%8A%A8%E5%BD%A2%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://answerend42.github.io/Answerend42.github.io/2020/03/08/P6180%20%E3%80%90%5BUSACO15DEC%5DBreed%20Counting%20S%E3%80%91/P6180%20%E3%80%90%5BUSACO15DEC%5DBreed%20Counting%20S%E3%80%91/">P6180 【[USACO15DEC]Breed Counting S】</a>这篇文章中，我介绍并使用了前缀和的方法来通过该题，这次来讲前缀和的扩展——二维前缀和。</p>
<a id="more"></a>
<h2 id="什么是二维前缀和"><a href="#什么是二维前缀和" class="headerlink" title="什么是二维前缀和"></a>什么是二维前缀和</h2><p>首先，并不是针对二维数组中的每一横行作前缀和。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>这次，我们的前缀和数组 $b$ 的定义如下</p>
<script type="math/tex; mode=display">
b_{x,y}=\sum_{i=1}^x\sum_{j=1}^ya_{i,j}</script><p>如果您看不懂或者懒得看这个式子，不妨看看另一个形象一点的介绍</p>
<p>我们认为 $b<em>{x,y}$ 就是 $a</em>{x,y}$ ​左上方矩形的所有数之和。</p>
<p>我用 Excel 画了这么一张图，其中黄色为原数组 $a$ 黑色为前缀和数组 $b$ 红色部分为二者中相等的部分，也就是说 $b$ 的红色部分代表的是 $a$ 红色部分的和</p>
<p><img src="https://pic.downk.cc/item/5e6e4ebfe83c3a1e3a0edc10.png" alt=""></p>
<h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>怎么得到 $b$ 数组呢？</p>
<p>如果我们要得到下图中被框起来的 $b$ 数组</p>
<p><img src="https://pic.downk.cc/item/5e6e517ee83c3a1e3a0fe10f.png" alt=""></p>
<p>可以如下图一样操作</p>
<p><img src="https://pic.downk.cc/item/5e6e52b2e83c3a1e3a103c2c.png" alt=""></p>
<p>不难发现，也就是加上 $b$ 中上方和左边的数（红色标识），去掉重复的部分（左上方橙色标识），加上原本没有的数（绿色标识）</p>
<p>给出公式</p>
<script type="math/tex; mode=display">
b_{x,y}=b_{x-1,y}+b_{x,y-1}-b_{x-1,y-1}+a_{x,y}</script><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>要知道 $(x1,y1)-(x2,y2)$ 矩阵的值，一样可以由上述思想推出。</p>
<p>以求 $(2,2)-(3,3)$ 为例</p>
<p><img src="https://pic.downk.cc/item/5e6e56f4e83c3a1e3a11ae76.png" alt=""></p>
<p>经过观察可得答案就是 <script type="math/tex">b_{x2,y2}-b_{x1-1,y2}-b_{x2,y1-1}+b_{x1-1,y1-1}</script></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>先gugugu了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>二维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P1434 [SHOI2002]滑雪</title>
    <url>/2020/03/11/lg1434/</url>
    <content><![CDATA[<p> <a href="https://www.luogu.org/problemnew/show/P1434" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​    Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure>
<p>​    一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24－17－16－1$（从 $24$ 开始，在 $1$ 结束）。当然 $25－24－23－\ldots－3－2－1$ 更长。事实上，这是最长的一条。</p>
<a id="more"></a>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p><strong>输入格式</strong></p>
<p>输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。</p>
<p><strong>输出格式</strong></p>
<p>输出区域中最长滑坡的长度。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure>
<p>输出1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于 $100\%$ 的数据，$1\leq R,C\leq 100$。</p>
<h2 id="40分做法（裸dfs）"><a href="#40分做法（裸dfs）" class="headerlink" title="40分做法（裸dfs）"></a>40分做法（裸dfs）</h2><p>​    从每个点出发搜一遍，统计最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[<span class="number">105</span>][<span class="number">105</span>], ans;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    ans = max(len, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || e[xx][yy] &gt; e[x][y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(xx, yy, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dfs(i, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="50分做法（加错误的记忆化）"><a href="#50分做法（加错误的记忆化）" class="headerlink" title="50分做法（加错误的记忆化）"></a>50分做法（加错误的记忆化）</h2><p>​    加入一个错误的记忆化，居然加了10分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[<span class="number">105</span>][<span class="number">105</span>], ans, p[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x][y] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p[x][y];  <span class="comment">// update</span></span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || e[xx][yy] &gt; e[x][y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        maxn = max(maxn, dfs(xx, yy) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x][y] = maxn;  <span class="comment">// update</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            ans = max(dfs(i, j), ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="100分做法（正确的记忆化）"><a href="#100分做法（正确的记忆化）" class="headerlink" title="100分做法（正确的记忆化）"></a>100分做法（正确的记忆化）</h2><p>​    在原先基础上改进一下 <code>e[xx][yy]&gt;e[x][y]</code> 改为 <code>e[xx][yy]&gt;=e[x][y]</code> AC 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[<span class="number">105</span>][<span class="number">105</span>], ans, p[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x][y] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p[x][y];</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || e[xx][yy] &gt;= e[x][y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        maxn = max(maxn, dfs(xx, yy) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x][y] = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            ans = max(dfs(i, j), ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    记忆化原理，搜到一个搜过的点，如果可以下一步到这个点，直接返回该点的长度，这样两条长度就能拼在一起了。</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>​    本文的创作过程受到了<a href="https://www.bilibili.com/video/av92448763?p=2" target="_blank" rel="noopener">嘉持的视频</a>的启发，特此感谢。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>深度优先搜索dfs</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P1135 奇怪的电梯</title>
    <url>/2020/03/11/lg1135/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1135" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​    呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼$(1 \le i \le N)$ 上有一个数字 $K_i(0 \le K_i \le N)$。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3 ,1 ,2 ,5$ 代表了$K_i(K_1=3,K_2=3,…)$，从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？</p>
<a id="more"></a>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p><strong>输入格式</strong></p>
<p>共二行。</p>
<p>第一行为 $3$ 个用空格隔开的正整数，表示 $N,A,B(1≤N≤200, 1≤A,B≤N)$。</p>
<p>第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。</p>
<p><strong>输出格式</strong></p>
<p>一行，即最少按键次数,若无法到达，则输出 $−1$。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">3 3 1 2 5</span><br></pre></td></tr></table></figure>
<p>输出1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="解法（bfs）"><a href="#解法（bfs）" class="headerlink" title="解法（bfs）"></a>解法（bfs）</h2><p>​    一道很简单的 bfs 裸题，根据题意可知，每一层至多有两种情况，向上或者向下当前层数，既然要求最少按几次按钮当然是用 bfs。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> n=read(),a=read(),b=read(),p[<span class="number">205</span>],book[<span class="number">100005</span>];</span><br><span class="line">Node t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d[]=&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(book,<span class="number">-1</span>,<span class="keyword">sizeof</span>(book));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=read();</span><br><span class="line">    Node t1;</span><br><span class="line">    t1.f=a;</span><br><span class="line">    t1.step=<span class="number">0</span>;</span><br><span class="line">    book[a]=<span class="number">0</span>;</span><br><span class="line">    q.push(t1);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(t.f==b)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tf;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">1</span>)</span><br><span class="line">                tf=t.f+p[t.f];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tf=t.f-p[t.f];</span><br><span class="line">            <span class="keyword">if</span>(tf&lt;<span class="number">1</span>||tf&gt;n||book[tf]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            book[tf]=<span class="number">1</span>;</span><br><span class="line">            Node t2;</span><br><span class="line">            t2.f=tf;</span><br><span class="line">            t2.step=t.step+<span class="number">1</span>;</span><br><span class="line">            q.push(t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(t.f==b)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,t.step);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>广度优先搜索bfs</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P1057 传球游戏</title>
    <url>/2020/03/09/lg1057/</url>
    <content><![CDATA[<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>​    有 $n$ 个人围坐成环，从 $1$ 开始传递，每次可将球传给相邻的人，问 $m$ 次传递后回到 $1$ 的方案数。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​    这一题很容易想到用搜索算法，但是会超时。我们不妨这样想，如果存在 $m$ 次传递后回到 $1$ 的情况，也就是意味着 $m-1$ 次传递到了 $n$ 或者 $2$ ， $m-2$ 次传递到了 $n-1$ 或者 $3$ 或者 $1$ 。我们就可以脑洞大开一下，求解传递 $k$ 次到 $p$ 的方案数，不就是传递 $k-1$ 次到 $p-1$ 和 $p+1$ 的方案数之和吗？（当然， $p=1$ 时是 $n$ 和 $2$ ）这就是状态的转移。</p>
<p>​    在这里，我用 <code>f[i][j]</code>  表示经过 $j$ 次传递到 $i$ 的方案数。</p>
<p>​    有状态转移公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{i,j}&=f_{i-1,j-1}+f_{i+1,j-1} (i\neq1,i\neq n) \\
f_{i,j}&=f_{n,j-1}+f_{i+1,j-1} (i=1) \\
f_{i,j}&=f_{i-1,j-1}+f_{1,j-1} (i=n)
\end{aligned}</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="comment">// f[i][j]=f[i-1][j-1]+f[i+1][j-1]</span></span><br><span class="line"><span class="comment">// f[i][j]表示传到了i 传递了j次的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                f[i][j] = f[n][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">// 1可以从n传，也可以从n+1传</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n)</span><br><span class="line">                f[i][j] = f[<span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">// n可以从1传，也可以从n-1传</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//其余都是i+1,i-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P6180 【[USACO15DEC]Breed Counting S】</title>
    <url>/2020/03/08/lg6180/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6180" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>  给出 $n$ 头奶牛，每头可分为三种，对于 $q$ 次询问，给出区间内各种奶牛的数量。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的数据范围限制为 $N,Q\leq10^5$ ，肯定不能够使用暴力对于每一个区间跑一遍统计。这一题有只要求查询而不要求修改，很自然就想到了前缀和。</p>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>那么什么是前缀和呢？</p>
<p>根据<a href="https://oi-wiki.org/basic/prefix-sum/" target="_blank" rel="noopener">OI Wiki 上的解释</a></p>
<blockquote>
<p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 $n$ 项的和”。</p>
</blockquote>
<p>如果用数组 $a$ 和其前缀和数组 $b$ 表示出来</p>
<p>$a_1=1,a_2=5,a_3=3,a_4=2,…$</p>
<p>则数组 $b$</p>
<p>$b_1=1,b_2=6,b_3=9,b_4=11,…$</p>
<p>不难推出式子</p>
<script type="math/tex; mode=display">
b_i=b_{i-1}+a_i</script><p>如果要查询数组 $a$ 从 $l$ 到 $r$ 之间所有数的和，只用输出 $b<em>r-b</em>{l-1}$​ ,</p>
<p>原理：</p>
<script type="math/tex; mode=display">
b_r=\sum_{i=1}^{r}a_i</script><script type="math/tex; mode=display">
b_{l-1}=\sum_{i=1}^{l-1}a_i</script><p>注意，一定是 $l-1$ 如果是 $l$ 就会将 $a_l$ 减去</p>
<p>根据上述，给出代码如下</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            f = -f;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, a[<span class="number">2</span>][N], b[<span class="number">2</span>][N], c[<span class="number">2</span>][N];</span><br><span class="line"><span class="comment">// a[0],b[0],c[0]为原始数组</span></span><br><span class="line"><span class="comment">// a[1],b[1],c[1]为对应的前缀和数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = read();</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            a[<span class="number">0</span>][i]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">            b[<span class="number">0</span>][i]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>)</span><br><span class="line">            c[<span class="number">0</span>][i]++;</span><br><span class="line">        a[<span class="number">1</span>][i] = a[<span class="number">1</span>][i - <span class="number">1</span>] + a[<span class="number">0</span>][i];</span><br><span class="line">        b[<span class="number">1</span>][i] = b[<span class="number">1</span>][i - <span class="number">1</span>] + b[<span class="number">0</span>][i];</span><br><span class="line">        c[<span class="number">1</span>][i] = c[<span class="number">1</span>][i - <span class="number">1</span>] + c[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a[<span class="number">1</span>][r] - a[<span class="number">1</span>][l - <span class="number">1</span>], b[<span class="number">1</span>][r] - b[<span class="number">1</span>][l - <span class="number">1</span>], c[<span class="number">1</span>][r] - c[<span class="number">1</span>][l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>前缀和的应用并不只上述这么简单，许多看似基础的算法也是如此，往往可以通过一些有趣的改进拓展到更多地方。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>二月做题记录</title>
    <url>/2020/03/03/%E4%BA%8C%E6%9C%88%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="2月2日"><a href="#2月2日" class="headerlink" title="2月2日"></a>2月2日</h2><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a></p>
<p>​    初见线段树感觉是真的不会，多打几次就熟练了</p>
<h2 id="2月3日"><a href="#2月3日" class="headerlink" title="2月3日"></a>2月3日</h2><p><a href="https://www.luogu.com.cn/problem/P3133" target="_blank" rel="noopener">P3133 [USACO16JAN]Radio Contact G</a></p>
<p>​    一道DP，不会推式子，以后要复习</p>
<h2 id="2月4日"><a href="#2月4日" class="headerlink" title="2月4日"></a>2月4日</h2><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a></p>
<p>​    线段树是真的不会，又多打了几次</p>
<h2 id="2月5日"><a href="#2月5日" class="headerlink" title="2月5日"></a>2月5日</h2><p><a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p>
<p>​    复习了dijkstra，还是不熟，多次WA</p>
<p><a href="https://www.luogu.com.cn/problem/P1040" target="_blank" rel="noopener">P1040 加分二叉树</a></p>
<p>​    一道DP，难想的是正好是l和r的特殊情况</p>
<h2 id="2月6日"><a href="#2月6日" class="headerlink" title="2月6日"></a>2月6日</h2><p><a href="https://www.luogu.com.cn/problem/P1063" target="_blank" rel="noopener">P1063 能量项链</a></p>
<p>​    <code>f[l][r]=max(f[l][r],f[l][k]+f[k+1][r]+a[l]*a[k+1]*a[r+1])</code></p>
<p>​    这一题是个区间DP，类似这种项链的题，大多是断开然后复制成为一长串</p>
<p><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">P1880 [NOI1995]石子合并</a></p>
<p>​    区间DP，处理方法同上</p>
<p><a href="https://www.luogu.com.cn/problem/P1970" target="_blank" rel="noopener">P1970 花匠</a></p>
<p>​    DP，只用满足一高一低</p>
<p><a href="https://www.luogu.com.cn/problem/P1807" target="_blank" rel="noopener">P1807 最长路</a></p>
<p>​    最短路的应用，只需要加边的时候取负数按照最短路跑，最后输出再取一次负数</p>
<p><a href="https://www.luogu.com.cn/problem/P1601" target="_blank" rel="noopener">P1601 A+B Problem（高精）</a></p>
<p>​    vector倒着储存，竖式计算并进位</p>
<h2 id="2月7日"><a href="#2月7日" class="headerlink" title="2月7日"></a>2月7日</h2><p><a href="https://www.luogu.com.cn/problem/P1077" target="_blank" rel="noopener">P1077 摆花</a></p>
<p>​    简单的线性DP</p>
<h2 id="2月8日"><a href="#2月8日" class="headerlink" title="2月8日"></a>2月8日</h2><p><a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">P3374 【模板】树状数组 1</a></p>
<p>​    模板题，但是我真的不是很懂 <a href="https://www.bilibili.com/video/av69667943?from=search&amp;seid=16890382504120585239" target="_blank" rel="noopener">推荐视频</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3388" target="_blank" rel="noopener">P3388 【模板】割点（割顶）</a></p>
<p>​    Tarjan挺有意思的，dfs能玩出花</p>
<h2 id="2月10日"><a href="#2月10日" class="headerlink" title="2月10日"></a>2月10日</h2><p><a href="https://www.luogu.com.cn/problem/P1086" target="_blank" rel="noopener">P1086 花生采摘</a></p>
<p>​    一直想做的题，从国庆拖到了现在，重要条件，它只会强制寻找当前最大的，而不会动态寻找能拿走的。</p>
<p>也就是说，最大的不一定能拿走，不能拿走则之后的它都不会拿</p>
<p><a href="https://www.luogu.com.cn/problem/P1546" target="_blank" rel="noopener">P1546 最短网络 Agri-Net</a></p>
<p>​    一道最小生成树模板题</p>
<h2 id="2月11日"><a href="#2月11日" class="headerlink" title="2月11日"></a>2月11日</h2><p><a href="https://www.luogu.com.cn/problem/P2015" target="_blank" rel="noopener">P2015 二叉苹果树</a></p>
<p>​    AC了但确实不会，要复习</p>
<p><a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">P1352 没有上司的舞会</a></p>
<p>​    我的树形DP入门题</p>
<h2 id="2月14日"><a href="#2月14日" class="headerlink" title="2月14日"></a>2月14日</h2><p><a href="https://www.luogu.com.cn/problem/P1195" target="_blank" rel="noopener">P1195 口袋的天空</a></p>
<p>​    一道最小生成树模板题，但是题面很美</p>
<p><a href="https://www.luogu.com.cn/problem/P1938" target="_blank" rel="noopener">P1938 [USACO09NOV]Job Hunt S</a></p>
<p>​    这一题直接跑最长路，飞机航线建边时用机票钱减去挣的钱</p>
<p><a href="https://www.luogu.com.cn/problem/P1209" target="_blank" rel="noopener">P1209 [USACO1.3]修理牛棚 Barn Repair</a></p>
<p>​    按照每两个之间的距离作为排序条件，贪心就好了</p>
<p><a href="https://www.luogu.com.cn/problem/P2853" target="_blank" rel="noopener">P2853 [USACO06DEC]牛的野餐Cow Picnic</a></p>
<p>​    每次都 dfs，如果某一个点正好被访问 $k$ 次，肯定所有牛都能到</p>
<p><a href="https://www.luogu.com.cn/problem/P3353" target="_blank" rel="noopener">P3353 在你窗外闪耀的星星</a></p>
<p>​    很美的题面，直接前缀和解决，有个坑点是同一位置上多颗星星亮度叠加</p>
<p><a href="https://www.luogu.com.cn/problem/P4057" target="_blank" rel="noopener">P4057 [Code+#1]晨跑</a></p>
<p>​    小学数学问题，求出三数的最小公倍数即可</p>
<p>​    <script type="math/tex">\operatorname{lcm} (a,b) = \dfrac{a \times b}{\gcd(a,b)}</script>​</p>
<h2 id="2月18日"><a href="#2月18日" class="headerlink" title="2月18日"></a>2月18日</h2><p><a href="https://www.luogu.com.cn/problem/P1141" target="_blank" rel="noopener">P1141 01迷宫</a></p>
<p>​    好久都是70分，自己写的记忆化是90分，按照题解终于AC</p>
<p><a href="https://www.luogu.com.cn/problem/P2996" target="_blank" rel="noopener">P2996 [USACO10NOV]Visiting Cows G</a></p>
<p>​    这一题和 <a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">P1352 没有上司的舞会</a> 其实是一道题</p>
<p><a href="https://www.luogu.com.cn/problem/P2242" target="_blank" rel="noopener">P2242 公路维修问题</a></p>
<p>​    这一题和 <a href="https://www.luogu.com.cn/problem/P1209" target="_blank" rel="noopener">P1209 [USACO1.3]修理牛棚 Barn Repair</a> 其实是一道题</p>
<h2 id="2月19日"><a href="#2月19日" class="headerlink" title="2月19日"></a>2月19日</h2><p><a href="https://www.luogu.com.cn/problem/P1009" target="_blank" rel="noopener">P1009 阶乘之和</a></p>
<p>​    综合了高精度乘法和加法</p>
<p><a href="https://www.luogu.com.cn/problem/P1443" target="_blank" rel="noopener">P1443 马的遍历</a></p>
<p>​    简单的 bfs</p>
<h2 id="2月21日"><a href="#2月21日" class="headerlink" title="2月21日"></a>2月21日</h2><p><a href="https://www.luogu.com.cn/problem/P5016" target="_blank" rel="noopener">P5016 龙虎斗</a></p>
<p>​    我一直以为我过了，忘了一个判断</p>
<p><a href="https://www.luogu.com.cn/problem/UVA10815" target="_blank" rel="noopener">UVA10815 安迪的第一个字典 Andy’s First Dictionary</a></p>
<p>​    跟着紫书学习，c++11的<code>auto</code>太爽了</p>
<h2 id="2月23日"><a href="#2月23日" class="headerlink" title="2月23日"></a>2月23日</h2><p><a href="https://www.luogu.com.cn/problem/UVA11292" target="_blank" rel="noopener">UVA11292 Dragon of Loowater</a></p>
<p>​    跟着紫书学习，这种精简的风格我也想学会</p>
<p><a href="https://www.luogu.com.cn/problem/UVA11462" target="_blank" rel="noopener">UVA11462 Age Sort</a></p>
<p>​    跟着紫书学习，桶排的优势</p>
<h2 id="2月25日"><a href="#2月25日" class="headerlink" title="2月25日"></a>2月25日</h2><p><a href="https://www.luogu.com.cn/problem/P1803" target="_blank" rel="noopener">P1803 凌乱的yyy / 线段覆盖</a></p>
<p>​    简单贪心</p>
<h2 id="2月26日"><a href="#2月26日" class="headerlink" title="2月26日"></a>2月26日</h2><p><a href="https://www.luogu.com.cn/problem/UVA1184" target="_blank" rel="noopener">UVA1184 Air Raid</a></p>
<p>​    二分图最小路径覆盖</p>
<p><a href="https://www.luogu.com.cn/problem/P1908" target="_blank" rel="noopener">P1908 逆序对</a></p>
<p>​    按照 <a href="http://www.wjyyy.top/277.html" target="_blank" rel="noopener">wjyyy的博客</a> 打的，实际不太会，需要复习</p>
<p>​    update 现在可以用树状数组过了，归并还是不会</p>
<p><a href="https://www.luogu.com.cn/problem/P1113" target="_blank" rel="noopener">P1113 杂务</a></p>
<p>​    很久以前就以为过了，但是实际上判断条件写错了…</p>
<h2 id="2月28日"><a href="#2月28日" class="headerlink" title="2月28日"></a>2月28日</h2><p><a href="https://www.luogu.com.cn/problem/P3368" target="_blank" rel="noopener">P3368 【模板】树状数组 2</a></p>
<p>​    差分方法实现区间修改</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    碍于篇幅所限，一些重复练习的题没有放出来，一些过水的题也已经隐藏。一个月以来感触最深的就是熟能生巧，线段树打到第五遍还是不熟，现在打起来飞快。一些DP仍然不会推式子，一些模拟仍然不太熟练，高精度也是半生不熟，粗心的错误也爱犯，但总而言之，有那么一点微小的进步吧。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>做题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>P3379 【模板】最近公共祖先（LCA）</title>
    <url>/2020/03/01/lg3379/</url>
    <content><![CDATA[<p>update on 2020.4.5 新增 tarjan 算法。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    LCA（Lowest Common Ancestor），即最近公共祖先。在一张图中，要找到两个节点的最近公共祖先，最朴素的算法就是分别从两个节点一层一层向上寻找，直到跳到一个相同的点，这个点就是两者的最近公共祖先。这样查找花费的时间代价太大，我们难以承受，于是就有了几种求LCA的算法。</p>
<a id="more"></a>
<h2 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h2><p>​    <a href="https://blog.csdn.net/JarjingX/article/details/8180560" target="_blank" rel="noopener">关于倍增入门</a></p>
<p>​    倍增刚开始学习真的是个很令人讨厌的东西，当我第一次看倍增相关的知识时，我很难理解，但是仔细一想其实不难。我们想象自己就是那只小白兔，尝试跳 1,2,4,8,……($2^0,2^1,2^2,2^3,……,2^n$)步,如果这一步跳跃比目标大，就换用更小的一步，如果换了之后小于目标，就跳这么一步，从新位置开始重复上述过程直至到达目标。</p>
<h2 id="LCA（倍增）"><a href="#LCA（倍增）" class="headerlink" title="LCA（倍增）"></a>LCA（倍增）</h2><p>​    我们注意到，倍增可以看作是<strong>“跳步”</strong>，而我们之前所采用的朴素算法也类似于跳步（只不过每次只跳一位），我们能不能将倍增的思想用于寻找最近公共祖先呢？</p>
<p>​    答案显然是可以的。</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>​    我们既然采用倍增，就需要知道对于每一个点跳 $2^k$ 步会到达何方，这里我们不妨用 <code>f[i][j]</code>来表示从 $i$ 号点出发，跳跃 $2^j$ 步将会到达的点。</p>
<p>​    同时我们有 $2^2=2^1 \times2^1$ ，以此类推又有 $2^k=2^{k-1}\times2^{k-1}$ ，那么跨越 $2^j$ 个格子也就是先跨越 $2^{j-1}$ 个格子 (<code>f[i][j-1]</code>) 再跨越 $2^{j-1}$ 个格子 (<code>f[f[i][j-1]][j-1]</code>) 。于是有了如下公式</p>
<script type="math/tex; mode=display">
f(i,j)=f(f(i,j-1),j-1)</script><p>​    于是，我们预处理 f 数组，并按照上述朴素算法执行向上跳的操作。</p>
<p>​    可是，这样的算法我们很快能举出反例</p>
<p>​    <img src="https://pic.downk.cc/item/5e5be3e5773ff94fc65c4038.png"  /></p>
<p>​    我们选择16,17两个节点，在尝试跳 $2^2$ 步时共同跳到了1号点，然而1号点并不是<strong>最近</strong>公共祖先。</p>
<p>​    <del>看来步子确实不能迈得太大。</del></p>
<p>​    我们这里采取的方法是实现判断要跳的点是否为同一个点，如果是，则不跳，那么最终会发现，两个点一直没有跳，那么16,17的父亲也就是自己的最近公共祖先。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    我们可以通过一个dfs来实现每一个节点的深度表示，儿子节点深度为父亲节点深度+1。同时我们还能够完成对于 f 数组的初始化，不过这里并不是向后跳，而是向着根节点跳（也可以认为是在向上跳）。</p>
<p>​    给出代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u]=dep[father]+<span class="number">1</span>;<span class="comment">//dep表示深度，通常都是深度深的先跳</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=dep[u];i++)<span class="comment">//(1&lt;&lt;i) 就是 2^i</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p=v[i];</span><br><span class="line">        <span class="keyword">if</span>(p==father) <span class="keyword">continue</span>;<span class="comment">//这个判定是为了防止回到父亲节点，因为用了无向边</span></span><br><span class="line">        f[p][<span class="number">0</span>]=u;</span><br><span class="line">        dfs(p,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    有了这一步，lca 的思维难度便一点都不大了</p>
<p>​    给出代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y])</span><br><span class="line">        swap(x,y);</span><br><span class="line">    <span class="comment">//保证x的深度&gt;y的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从2^20到2^0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">            x=f[x][i];</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;<span class="comment">//重合就不能跳了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])<span class="comment">//跳跃！</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];<span class="comment">//最后找到的两点的唯一父亲就是最近公共祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dfs(root,0);</span><br><span class="line">lca(a,b);</span><br></pre></td></tr></table></figure>
<p>​    本题就被我们顺利地解决了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>,M = <span class="number">500005</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="keyword">int</span> v[M],first[N],nxt[M],dep[N],idx,f[N][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    idx++;</span><br><span class="line">    v[idx]=y;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u]=dep[father]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=dep[u];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p=v[i];</span><br><span class="line">        <span class="keyword">if</span>(p==father) <span class="keyword">continue</span>;</span><br><span class="line">        f[p][<span class="number">0</span>]=u;</span><br><span class="line">        dfs(p,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y])</span><br><span class="line">        swap(x,y);</span><br><span class="line">    <span class="comment">//保证x的深度&gt;y的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">            x=f[x][i];</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dfs(root,0);</span></span><br><span class="line"><span class="comment">lca(a,b);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LCA 倍增求法 每次选取我们能够跳的最大高度</span></span><br><span class="line"><span class="comment">    如果跳到了同一层级，继续，直到最终不能再使深度变小</span></span><br><span class="line"><span class="comment">    前提 不能相遇</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b);add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lca(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCA（tarjan）"><a href="#LCA（tarjan）" class="headerlink" title="LCA（tarjan）"></a>LCA（tarjan）</h2><p>Tarjan 这个大神犇又来造福大家了，全新的炫酷 dfs 神奇应用 LCA。</p>
<p>这是一个离线算法，即最终一次性跑完所有查询，原理是通过一次 dfs 实现。</p>
<p>tarjan 算法基本思路：</p>
<ol>
<li><p>任选一个点为根节点，从根节点开始进行DFS。</p>
</li>
<li><p>标记当前访问到的点 u 已经被访问过。</p>
</li>
<li><p>寻找与当前点 u 有询问关系的点 v。</p>
</li>
<li><p>若是 v 已经被访问过了，则可以确认 u 和 v 的最近公共祖先为 v 被合并到的父亲节点 a。</p>
</li>
<li><p>遍历点 u 的所有子节点 v。</p>
</li>
<li><p>若 v 还有子节点，返回2，否则下一步。</p>
</li>
<li><p>合并 v 到 u 上。</p>
</li>
</ol>
<p>具体思路先 gugugu。</p>
<p>给出代码如下</p>
<p>基于 vector 实现（速度较慢，明明是线性算法愣是比倍增慢还 T 了3个点，只能O2）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VI vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,lca;</span><br><span class="line">&#125; qe[N];</span><br><span class="line"><span class="keyword">int</span> n,m,f[N],book[N],a,s;</span><br><span class="line">VI e[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==f[x]?x:f[x]=getf(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    book[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q[x].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx=q[x][i];</span><br><span class="line">        <span class="keyword">if</span>(qe[idx].u!=x) a=qe[idx].u;</span><br><span class="line">        <span class="keyword">else</span> a=qe[idx].v;</span><br><span class="line">        <span class="keyword">if</span>(book[a]) qe[idx].lca=getf(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[x].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!book[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            f[y]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">100000</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getcha();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=read(),m=read(),s=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        e[x].pb(y);e[y].pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        qe[i].u=read(),qe[i].v=read();</span><br><span class="line">        q[qe[i].u].pb(i);q[qe[i].v].pb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    tarjan(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qe[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于链式前向星实现（常数小，但是实现比较复杂）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">7</span>,M= <span class="number">2</span> * N;</span><br><span class="line"><span class="keyword">int</span> idx,first[N],nxt[M],v[M],book[N],f[N],a,n,m,s;</span><br><span class="line"><span class="keyword">int</span> idx1,q_first[N],q_nxt[M],q_v[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,lca;</span><br><span class="line">&#125; qe[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    idx++;</span><br><span class="line">    v[idx]=y;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_q</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    idx1++;</span><br><span class="line">    q_v[idx1]=y;</span><br><span class="line">    q_nxt[idx1]=q_first[x];</span><br><span class="line">    q_first[x]=idx1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==f[x]?x:f[x]=getf(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    book[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=q_first[x];i;i=q_nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> qv=q_v[i];</span><br><span class="line">        <span class="keyword">if</span>(book[qv]) &#123;</span><br><span class="line">            qe[i].lca=getf(qv);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>) qe[i+<span class="number">1</span>].lca=qe[i].lca;</span><br><span class="line">            <span class="keyword">else</span> qe[i<span class="number">-1</span>].lca=qe[i].lca;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[x];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y=v[i];</span><br><span class="line">        <span class="keyword">if</span>(!book[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            f[y]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">100000</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getcha();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=read(),m=read(),s=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        add(x,y);add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        qe[i].u=read(),qe[i].v=read();</span><br><span class="line">        add_q(qe[i].u,qe[i].v);add_q(qe[i].v,qe[i].u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    tarjan(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qe[i*<span class="number">2</span>].lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    作者很久之前就想学习 LCA ，并多次查阅 OI Wiki 但实属能力不足，一直没有看懂，非常感谢</p>
<p>这个 <a href="https://www.bilibili.com/video/av88792056" target="_blank" rel="noopener">教学视频</a> 。可以说是非常直观了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://oi-wiki.org/graph/lca/" target="_blank" rel="noopener">最近公共祖先 OI Wiki</a></p>
<p><a href="https://www.bilibili.com/video/av88792056" target="_blank" rel="noopener">【manim | 算法】7分钟学会倍增法求解LCA</a></p>
<p><a href="https://blog.csdn.net/JarjingX/article/details/8180560" target="_blank" rel="noopener">【白话系列】倍增算法</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title>P1009 阶乘之和</title>
    <url>/2020/02/21/lg1009/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在洛谷上刷题时遇见这么一道题 <a href="https://www.luogu.com.cn/problem/P1009" target="_blank" rel="noopener">P1009 阶乘之和</a> ，题面简单好理解，适合和我一样菜的 OIer。二话不说，我抄起手中一把梭。</p>
<p><img src="https://i.loli.net/2020/02/25/jkrEdNQLntsaIbR.gif" alt=""></p>
<p>​    提交，Judge，一气呵成。</p>
<p><img src="https://pic.downk.cc/item/5e4f813b48b86553ee32c0fd.png" alt=""></p>
<p>​    然而50Pts…</p>
<a id="more"></a>
<h2 id="找锅"><a href="#找锅" class="headerlink" title="找锅"></a>找锅</h2><p>​    明显的，程序出了锅。</p>
<blockquote>
<p>怀疑并不是缺点。总是疑，而并不下断语，这才是缺点。    ——鲁迅</p>
</blockquote>
<p>​    为什么会 Wa 呢，这是因为数据范围 $n \leq50$ 实际验算确认，unsigned long long最大可储存的阶乘是 $20!$</p>
<p>,当计算 $21!$​ 时，就出现了溢出的错误。</p>
<h2 id="修锅"><a href="#修锅" class="headerlink" title="修锅"></a>修锅</h2><p>​    是时候介绍主角——高精度了。高精度适用于无法直接用类型储存的数值计算，计算方式类似于竖式算法。竖式算法是通过同一位的两数加减乘除后进位的算法。</p>
<p><img src="https://oi-wiki.org/math/images/plus.png" alt=""></p>
<p>​                                                                                                                                                                        图源自OI wiki</p>
<h3 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h3><p>​    既然不能用一种类型储存，很自然让人想到字符串(string)，因为string可以动态扩容。但其实string的本质也就是一个数组，而高精度需要储存的都是数字，为什么不用整形(int)数组呢？如果用了int，却无法估计最终会有多少位数时，不妨动态扩容，也就是使用vector作为基类。一阵分析后，我们开始用vector。</p>
<p>​    竖式运算中由最低位向最高位逐步计算，但是不能估计最高位是否可能进位，vector的扩容是向后的，即越后的数越后出现，那么较低位的数就理所应当先出现，这就需要逆序储存到vector。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	v.push_back(s[i]-<span class="string">'0'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.size()&lt;B.size())	<span class="keyword">return</span> add(B,A);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>,len=A.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t+=A[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.size())	t+=B[i];</span><br><span class="line">		C.push_back(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t)	C.push_back(t);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先需要判断A和B谁位数更大，这里让A的位数始终大于B。因为A的位数更大，保证每一位加法都可以有A的这一位参与其中，但B就不一定了，正如上例中百位数只有A的9参与了计算。同时在计算每一位的和之后将该值对10取模（模拟进位过程），然后将该值除以10，最后判断最后一位是否需要进位，如果需要就将最后一位加入，最终返回一个vector。</p>
<h4 id="乘法-高精度乘以低精度"><a href="#乘法-高精度乘以低精度" class="headerlink" title="乘法 高精度乘以低精度"></a>乘法 高精度乘以低精度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size()||t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;A.size())	t+=A[i]*b;</span><br><span class="line">		C.push_back(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（作者并不会高精度乘以高精度，以后再更）</p>
<p>​    和加法类似，同样是每一位乘以b之后对10取模（进位）。值得一提的是这条语句<code>i&lt;A.size()||t</code>因为乘法运算进位有可能不止一位，要考虑t不断进位的情况。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    有了以上步骤，我们可以很快打出本题代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, b, ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size())</span><br><span class="line">        <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, len = A.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a.clear();</span><br><span class="line">        a.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            b = mul(a, j);</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = add(ans, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    题解到这里就结束了，以下是一些作者的题外话。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>​    本题是 noip 1999 的题目，当时的竞赛不分普及组和提高组，可以使用的语言包括 basic ，方便好用的 stl 也没有解禁，甚至于整个中国也没有现在如此之多的 OIer 为了理想而奋斗。现如今的 OI 风雨交加，会有很多很多的 OIer 们因为现实不得不退役，但我认为在 OI 赛场上奋力拼搏，勤恳训练的日子会为所有参加竞赛、热爱竞赛的人留下永恒难忘的回忆。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1009 阶乘之和</title>
    <url>/2020/02/21/lg1009/lg1009/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在洛谷上刷题时遇见这么一道题 <a href="https://www.luogu.com.cn/problem/P1009" target="_blank" rel="noopener">P1009 阶乘之和</a> ，题面简单好理解，适合和我一样菜的 OIer。二话不说，我抄起手中一把梭。</p>
<p><img src="https://i.loli.net/2020/02/25/jkrEdNQLntsaIbR.gif" alt=""></p>
<p>​    提交，Judge，一气呵成。</p>
<p><img src="https://pic.downk.cc/item/5e4f813b48b86553ee32c0fd.png" alt=""></p>
<p>​    然而50Pts…</p>
<a id="more"></a>
<h2 id="找锅"><a href="#找锅" class="headerlink" title="找锅"></a>找锅</h2><p>​    明显的，程序出了锅。</p>
<blockquote>
<p>怀疑并不是缺点。总是疑，而并不下断语，这才是缺点。    ——鲁迅</p>
</blockquote>
<p>​    为什么会 Wa 呢，这是因为数据范围 $n \leq50$ 实际验算确认，unsigned long long最大可储存的阶乘是 $20!$</p>
<p>,当计算 $21!$​ 时，就出现了溢出的错误。</p>
<h2 id="修锅"><a href="#修锅" class="headerlink" title="修锅"></a>修锅</h2><p>​    是时候介绍主角——高精度了。高精度适用于无法直接用类型储存的数值计算，计算方式类似于竖式算法。竖式算法是通过同一位的两数加减乘除后进位的算法。</p>
<p><img src="https://oi-wiki.org/math/images/plus.png" alt=""></p>
<p>​                                                                                                                                                                        图源自OI wiki</p>
<h3 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h3><p>​    既然不能用一种类型储存，很自然让人想到字符串(string)，因为string可以动态扩容。但其实string的本质也就是一个数组，而高精度需要储存的都是数字，为什么不用整形(int)数组呢？如果用了int，却无法估计最终会有多少位数时，不妨动态扩容，也就是使用vector作为基类。一阵分析后，我们开始用vector。</p>
<p>​    竖式运算中由最低位向最高位逐步计算，但是不能估计最高位是否可能进位，vector的扩容是向后的，即越后的数越后出现，那么较低位的数就理所应当先出现，这就需要逆序储存到vector。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	v.push_back(s[i]-<span class="string">'0'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.size()&lt;B.size())	<span class="keyword">return</span> add(B,A);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>,len=A.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t+=A[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.size())	t+=B[i];</span><br><span class="line">		C.push_back(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t)	C.push_back(t);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先需要判断A和B谁位数更大，这里让A的位数始终大于B。因为A的位数更大，保证每一位加法都可以有A的这一位参与其中，但B就不一定了，正如上例中百位数只有A的9参与了计算。同时在计算每一位的和之后将该值对10取模（模拟进位过程），然后将该值除以10，最后判断最后一位是否需要进位，如果需要就将最后一位加入，最终返回一个vector。</p>
<h4 id="乘法-高精度乘以低精度"><a href="#乘法-高精度乘以低精度" class="headerlink" title="乘法 高精度乘以低精度"></a>乘法 高精度乘以低精度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;C;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size()||t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;A.size())	t+=A[i]*b;</span><br><span class="line">		C.push_back(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（作者并不会高精度乘以高精度，以后再更）</p>
<p>​    和加法类似，同样是每一位乘以b之后对10取模（进位）。值得一提的是这条语句<code>i&lt;A.size()||t</code>因为乘法运算进位有可能不止一位，要考虑t不断进位的情况。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    有了以上步骤，我们可以很快打出本题代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, b, ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size())</span><br><span class="line">        <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, len = A.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a.clear();</span><br><span class="line">        a.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            b = mul(a, j);</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = add(ans, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    题解到这里就结束了，以下是一些作者的题外话。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>​    本题是 noip 1999 的题目，当时的竞赛不分普及组和提高组，可以使用的语言包括 basic ，方便好用的 stl 也没有解禁，甚至于整个中国也没有现在如此之多的 OIer 为了理想而奋斗。现如今的 OI 风雨交加，会有很多很多的 OIer 们因为现实不得不退役，但我认为在 OI 赛场上奋力拼搏，勤恳训练的日子会为所有参加竞赛、热爱竞赛的人留下永恒难忘的回忆。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P3372 【模板】线段树 1</title>
    <url>/2020/02/20/lg3372/</url>
    <content><![CDATA[<blockquote>
<p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p>
<p>线段树可以在$\mathcal{O}(log N)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>
<p>线段树维护的信息，需要满足可加性，即能以可以接受的速度合并信息和修改信息，包括在使用懒惰标记时，标记也要满足可加性（例如取模就不满足可加性，对 取模然后对 取模，两个操作就不能合并在一起做）。</p>
<p>​                                                                                                                                                                    ——OI Wiki</p>
</blockquote>
<p>​    update on 2020.2.27 修改了标程，适当的压行</p>
<p>​    update on 2020.8.5 完善了措辞，更改了示例图片</p>
<a id="more"></a>
<h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>​    线段树，即利用分块思想将序列分为若干段并储存为树。线段树的每一个节点都代表着整个序列中的一段子区间。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>​    给定序列 $1,2,3,4,5,6,7,8,9,10$ 那么我们的树就长这个样子。</p>
<p><img src="https://pic.downk.cc/item/5e4e3b3f48b86553eed80f95.png" alt=""></p>
<p>​    注意，这里的节点中数字仅用于指示序列中元素位置，并非元素本身。“$1 \sim 10$”就是序列中 $1$ 号元素到 $10$ 号元素。</p>
<p>​    不难看出，如果我需要改动 $3$ 号节点，就需要依次向上更改每一个相关节点。</p>
<p><img src="https://pic.downk.cc/item/5f298d5114195aa5948bcddf.png" alt=""></p>
<h2 id="正式介绍"><a href="#正式介绍" class="headerlink" title="正式介绍"></a>正式介绍</h2><blockquote>
<p>要想使用树，先得有棵树。    </p>
</blockquote>
<h3 id="左右儿子的表示方式"><a href="#左右儿子的表示方式" class="headerlink" title="左右儿子的表示方式"></a>左右儿子的表示方式</h3><p>​    通过上述介绍，我们可以看出，线段树是一颗<strong>二叉树</strong>，那么节点 $i$ 的两个儿子编号为 $2i$ 和 $2i+1$。</p>
<p>​    由于下文中将多次引用，且为了保障代码的可读性，我们可以写两个函数 ls 和 rs 来表示左右儿子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(ll p)</span> </span>&#123;<span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(ll p)</span> </span>&#123;<span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>​    左移一位末位必定为0</p>
<script type="math/tex; mode=display">
p<<1|1 \iff (p<<1)+1</script><h3 id="向上传递参数"><a href="#向上传递参数" class="headerlink" title="向上传递参数"></a>向上传递参数</h3><p>​    刚刚我们说过，<strong>需要依次向上更改每一个相关节点</strong>。因此，我们需要向上传递参数。</p>
<script type="math/tex; mode=display">
\sum_{i=l}^ra_i=\sum_{i=l}^{r/2}a_i+\sum_{i=r/2+1}^{r}a_i</script><p>​    也就是说，节点p的值等于它的儿子节点的值之和。可依此写出 push_up 函数。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span> </span>&#123;ans[p]=ans[ls(p)]+ans[rs(p)];&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>​    有了这么三个函数，我们开始考虑建树。既然父亲节点的值取决于儿子节点的值，又是一棵二叉树，我们完全可以考虑<strong>递归</strong>建树。</p>
<p>​    思考：</p>
<ol>
<li><p>​    建树函数需要几个参数？</p>
<p>​    我这里用到了三个，分别是 ：</p>
<p>​        p（当前节点编号） l（当前节点所代表的序列的左端点） r（当前节点所代表的序列的右端点）    </p>
</li>
<li><p>​    递归终点呢？</p>
<p>​    不难看出，函数最终会运行到 $l=r$ 这种情况，对于这种单个的节点来说一定是没有儿子的，直接将其值储存就可以了，这也就是我们要找的递归终点。</p>
</li>
<li><p>​    回溯时我们应该做些什么？</p>
<p>​    直接将这一个节点已知的数据传递向父亲节点（push_up）。</p>
<p>给出建树的代码。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[p]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(ls(p),l,mid);</span><br><span class="line">    build(rs(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><h4 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h4><p>​    线段树支持修改，但要按照<strong>基本法</strong>来修改。基本法就是：尽量不去更新区间所包含的单点。</p>
<p>​    这句话也忒不像人话了，还是来解释一下。如果我们需要修改1~5这个区间，将该区间的值全部加上k。</p>
<p>​    正常想法是将每一个节点都加上k并上传，这样的时间复杂度是$\mathcal{O}(N)$的，我们不能接受。于是就有了偷懒的办法，也就是Lazy Propagation。</p>
<p>​    我们注意到1~5是正好被一个节点包含的一个区间，我们只需要将这个节点的值加上k*(5-1+1)就可以了，然后我们为它打上值为k的懒标记，并将标记传递下去，告知这个区间内所有节点都加上了k。时间复杂度也就变成了$\mathcal{O}(logN)$。</p>
<p>​    这种更改的操作我们用一个 f 函数来表示如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ll p, ll l, ll r, ll k)</span> </span>&#123;</span><br><span class="line">    tag[p] += k;                <span class="comment">//这个节点加上了k</span></span><br><span class="line">    ans[p] += k * (r - l + <span class="number">1</span>);  <span class="comment">//这个节点的实际更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递懒标记"><a href="#传递懒标记" class="headerlink" title="传递懒标记"></a>传递懒标记</h4><p>​    我们还需要向下传递，这种操作也就是类似于 push_up ，不过方向要相反。同时还要注意，向上传递时只有一条路，向下传递却有许多路，介于线段树是<strong>二叉树</strong>这种结构，我们可以对向下传递操作进行二分。</p>
<p>​    这里给出 push_down 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    f(ls(p), l, mid, tag[p]);</span><br><span class="line">    f(rs(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">    tag[p] = <span class="number">0</span>;  <span class="comment">//传递向下了之后p本身的标记就需要清零了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现区间修改"><a href="#实现区间修改" class="headerlink" title="实现区间修改"></a>实现区间修改</h4><p>​    终于可以区间修改了，和 push_down 一样，我们对修改的区间进行二分，分别处理每一段区间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl, ll nr, ll l, ll r, ll p, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果这一区间被整个需修改区间所包含</span></span><br><span class="line"><span class="comment">        直接对这一区间进行修改</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        f(p, l, r, k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就向下传递，进行二分</span></span><br><span class="line">    push_down(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid)</span><br><span class="line">        update(nl, nr, l, mid, ls(p), k);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid)</span><br><span class="line">        update(nl, nr, mid + <span class="number">1</span>, r, rs(p), k);</span><br><span class="line">    push_up(p);  <span class="comment">//当然，下层的修改在回溯时需要有序返回上层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>​    区间的查询类似于修改，同样是基于二分的思想，这里直接给出代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll q_x, ll q_y, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q_x &lt;= l &amp;&amp; r &lt;= q_y)</span><br><span class="line">        <span class="keyword">return</span> ans[p];</span><br><span class="line">    <span class="comment">//查询的区间包含了这一区间，直接返回，大大提高效率</span></span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在查询时将Lazy Propagation不断向下传递</span></span><br><span class="line">    push_down(p, l, r);</span><br><span class="line">    <span class="comment">//二分查询</span></span><br><span class="line">    <span class="keyword">if</span> (q_x &lt;= mid)</span><br><span class="line">        res += query(q_x, q_y, l, mid, ls(p));</span><br><span class="line">    <span class="keyword">if</span> (q_y &gt; mid)</span><br><span class="line">        res += query(q_x, q_y, mid + <span class="number">1</span>, r, rs(p));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="keyword">unsigned</span> ll a[N], ans[N &lt;&lt; <span class="number">2</span>], tag[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(ll p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(ll p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span> </span>&#123; ans[p] = ans[ls(p)] + ans[rs(p)]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    tag[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ans[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls(p), l, mid);</span><br><span class="line">    build(rs(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ll p, ll l, ll r, ll k)</span> </span>&#123;</span><br><span class="line">    tag[p] += k;</span><br><span class="line">    ans[p] += k * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    f(ls(p), l, mid, tag[p]);</span><br><span class="line">    f(rs(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">    tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl, ll nr, ll l, ll r, ll p, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr) &#123;</span><br><span class="line">        f(p, l, r, k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid)</span><br><span class="line">        update(nl, nr, l, mid, ls(p), k);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid)</span><br><span class="line">        update(nl, nr, mid + <span class="number">1</span>, r, rs(p), k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll q_x, ll q_y, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q_x &lt;= l &amp;&amp; r &lt;= q_y)</span><br><span class="line">        <span class="keyword">return</span> ans[p];</span><br><span class="line">    push_down(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q_x &lt;= mid)</span><br><span class="line">        res += query(q_x, q_y, l, mid, ls(p));</span><br><span class="line">    <span class="keyword">if</span> (q_y &gt; mid)</span><br><span class="line">        res += query(q_x, q_y, mid + <span class="number">1</span>, r, rs(p));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x, y, xx, yy, k, a1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a1);</span><br><span class="line">        <span class="keyword">if</span> (a1 == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">            update(x, y, <span class="number">1</span>, n, <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;xx, &amp;yy);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, query(xx, yy, <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>​    线段树对于绝大部分水平和我一样刚刚pj1=左右的选手都是很难一下搞懂的知识点，即使是对整个算法有着清晰的认识也很难一次就打对，一定要多打几次，多理解几次。可以适当尝试背诵并用笔默写整个代码，对于迅速找到自己卡壳的地方很有成效。</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>​    本文参考了<a href="https://www.luogu.com.cn/blog/pks-LOVING/senior-data-structure-qian-tan-xian-duan-shu-segment-tree" target="_blank" rel="noopener">皎月半洒花的博客</a>，特此感谢。</p>
<p>​    同时感谢观看本篇博客的朋友们，希望对本篇博客提出意见并指出我的不足之处。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1352 没有上司的舞会</title>
    <url>/2020/02/17/lg1352/</url>
    <content><![CDATA[<p>​    以此题作为树形DP的入门。</p>
<blockquote>
<p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。——OI Wiki</p>
</blockquote>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>​    我们从这一题给出的样例开始分析。</p>
<p><img src="https://pic.downk.cc/item/5e44bbd248b86553eea8f368.png" alt=""></p>
<p>​    由题意可知，对于每一个点，只有选或不选两种状态，且相邻的点不能同时选取。</p>
<p>​    考虑以 $i$ 作为根节点的子树中选取或不选取 $i$ 的两种情况。</p>
<p>​    <img src="https://pic.downk.cc/item/5e44bf1448b86553eea97e10.png" alt=""></p>
<p>​    由此就可以很容易得到递推公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(i,0)&=f(i,0)+\max \{ f(r,0),f(r,1) \} \\
f(i,1)&=f(i,1)+f(r,0)
\end{aligned}</script><p>​    那么 $\max { f(r,0),f(r,1) }$ 即为最终答案(r为根节点)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// f[i][0]表示以i为根的子树中不选i时的最大值</span></span><br><span class="line"><span class="comment">// f[i][1]表示以i为根的子树中选i时的最大值</span></span><br><span class="line"><span class="comment">// f[i][1]=r[u] f[i][1]+=f[v][0] 选i不选i的儿子</span></span><br><span class="line"><span class="comment">// f[i][0]+=max(f[i][1],f[i][0]) 不选i可选可不选i的儿子</span></span><br><span class="line"><span class="comment">//显然的 设整个子树的根为r max(f[r][0],f[r][1])就是最终的答案</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6005</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> r[N], f[N][<span class="number">2</span>], n, first[N], nxt[M], v[M], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    v[++idx] = y;</span><br><span class="line">    nxt[idx] = first[x];</span><br><span class="line">    first[x] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = r[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = v[i];</span><br><span class="line">        <span class="keyword">if</span> (p != father) &#123;  <span class="comment">//不判重则会导致死循环</span></span><br><span class="line">            dfs(p, u);      <span class="comment">//回溯push_up</span></span><br><span class="line">            f[u][<span class="number">0</span>] += max(f[p][<span class="number">0</span>], f[p][<span class="number">1</span>]);</span><br><span class="line">            f[u][<span class="number">1</span>] += f[p][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;k);</span><br><span class="line">        add(l, k);</span><br><span class="line">        add(k, l);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = max(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
</search>
